// -----------------------------------------------------------------------------
// AUTOGENERATED FILE – DO NOT EDIT DIRECTLY.
// Source: src/XAU_Swing_TrendEA_Pro.mq5 + src/modules/* (inlined).
// This bundled version exists for MetaTrader terminals where copying the
// accompanying modules directory is inconvenient. Developers should keep editing
// the modular sources under src/ and regenerate this bundle via
// ``python tools/bundle_ea.py`` when publishing a release.
// -----------------------------------------------------------------------------

//+------------------------------------------------------------------+
//| XAU_Swing_TrendEA_Pro.mq5                                        |
//| Refactored swing/breakout Expert Advisor for XAUUSD (MT5)        |
//| Session: 07:00-14:45, Bias votes: EMA20(H1)/EMA34(H4)/EMA50(D1)  |
//| Risk: ATR stop sizing, R-multiple partials/trailing/time-stop    |
//+------------------------------------------------------------------+
// v1.3 – 2024-05-08 – Directional score thresholds, adaptive ATR stop tightening,
//                     extended R-management defaults and richer entry logging.
#property strict

#include <Trade\Trade.mqh>

// --- BEGIN inlined module: modules/TesterCompat.mqh ---
//+------------------------------------------------------------------+
//| TesterCompat.mqh                                                 |
//| Compatibility helpers for tester statistics in constrained       |
//| environments.                                                    |
//+------------------------------------------------------------------+
#ifndef TESTERCOMPAT_MQH
#define TESTERCOMPAT_MQH

// Some build environments (for example static analysis harnesses) do not ship
// the MetaTrader tester headers.  Provide lightweight fallback definitions for
// the tester statistics identifiers so that the Expert Advisor can be parsed
// and tested without the official include files.

#ifndef STAT_INITIAL_DEPOSIT
   #define STAT_INITIAL_DEPOSIT        0
#endif
#ifndef STAT_WITHDRAWAL
   #define STAT_WITHDRAWAL             1
#endif
#ifndef STAT_PROFIT
   #define STAT_PROFIT                 2
#endif
#ifndef STAT_GROSS_PROFIT
   #define STAT_GROSS_PROFIT           3
#endif
#ifndef STAT_GROSS_LOSS
   #define STAT_GROSS_LOSS             4
#endif
#ifndef STAT_MAX_PROFITTRADE
   #define STAT_MAX_PROFITTRADE        5
#endif
#ifndef STAT_MAX_LOSSTRADE
   #define STAT_MAX_LOSSTRADE          6
#endif
#ifndef STAT_CONPROFITMAX
   #define STAT_CONPROFITMAX           7
#endif
#ifndef STAT_CONPROFITMAX_TRADES
   #define STAT_CONPROFITMAX_TRADES    8
#endif
#ifndef STAT_MAX_CONWINS
   #define STAT_MAX_CONWINS            9
#endif
#ifndef STAT_MAX_CONPROFIT_TRADES
   #define STAT_MAX_CONPROFIT_TRADES   10
#endif
#ifndef STAT_CONLOSSMAX
   #define STAT_CONLOSSMAX             11
#endif
#ifndef STAT_CONLOSSMAX_TRADES
   #define STAT_CONLOSSMAX_TRADES      12
#endif
#ifndef STAT_MAX_CONLOSSES
   #define STAT_MAX_CONLOSSES          13
#endif
#ifndef STAT_MAX_CONLOSS_TRADES
   #define STAT_MAX_CONLOSS_TRADES     14
#endif
#ifndef STAT_BALANCEMIN
   #define STAT_BALANCEMIN             15
#endif
#ifndef STAT_BALANCE_DD
   #define STAT_BALANCE_DD             16
#endif
#ifndef STAT_BALANCEDD_PERCENT
   #define STAT_BALANCEDD_PERCENT      17
#endif
#ifndef STAT_BALANCE_DDREL_PERCENT
   #define STAT_BALANCE_DDREL_PERCENT  18
#endif
#ifndef STAT_BALANCE_DD_RELATIVE
   #define STAT_BALANCE_DD_RELATIVE    19
#endif
#ifndef STAT_EQUITYMIN
   #define STAT_EQUITYMIN              20
#endif
#ifndef STAT_EQUITY_DD
   #define STAT_EQUITY_DD              21
#endif
#ifndef STAT_EQUITYDD_PERCENT
   #define STAT_EQUITYDD_PERCENT       22
#endif
#ifndef STAT_EQUITY_DDREL_PERCENT
   #define STAT_EQUITY_DDREL_PERCENT   23
#endif
#ifndef STAT_EQUITY_DD_RELATIVE
   #define STAT_EQUITY_DD_RELATIVE     24
#endif
#ifndef STAT_EQUITY_DDRELATIVE
   #define STAT_EQUITY_DDRELATIVE      STAT_EQUITY_DD_RELATIVE
#endif
#ifndef STAT_EXPECTED_PAYOFF
   #define STAT_EXPECTED_PAYOFF        25
#endif
#ifndef STAT_PROFIT_FACTOR
   #define STAT_PROFIT_FACTOR          26
#endif
#ifndef STAT_RECOVERY_FACTOR
   #define STAT_RECOVERY_FACTOR        27
#endif
#ifndef STAT_SHARPE_RATIO
   #define STAT_SHARPE_RATIO           28
#endif
#ifndef STAT_MIN_MARGINLEVEL
   #define STAT_MIN_MARGINLEVEL        29
#endif
#ifndef STAT_CUSTOM_ONTESTER
   #define STAT_CUSTOM_ONTESTER        30
#endif
#ifndef STAT_DEALS
   #define STAT_DEALS                  31
#endif
#ifndef STAT_TRADES
   #define STAT_TRADES                 32
#endif
#ifndef STAT_PROFIT_TRADES
   #define STAT_PROFIT_TRADES          33
#endif
#ifndef STAT_LOSS_TRADES
   #define STAT_LOSS_TRADES            34
#endif
#ifndef STAT_SHORT_TRADES
   #define STAT_SHORT_TRADES           35
#endif
#ifndef STAT_LONG_TRADES
   #define STAT_LONG_TRADES            36
#endif
#ifndef STAT_PROFIT_SHORTTRADES
   #define STAT_PROFIT_SHORTTRADES     37
#endif
#ifndef STAT_PROFIT_LONGTRADES
   #define STAT_PROFIT_LONGTRADES      38
#endif
#ifndef STAT_PROFITTRADES_AVGCON
   #define STAT_PROFITTRADES_AVGCON    39
#endif
#ifndef STAT_LOSSTRADES_AVGCON
   #define STAT_LOSSTRADES_AVGCON      40
#endif
#ifndef STAT_COMPLEX_CRITERION
   #define STAT_COMPLEX_CRITERION      41
#endif
#ifndef STAT_MODELLING_QUALITY
   #define STAT_MODELLING_QUALITY      42
#endif
#ifndef STAT_START_TRADE_TIME
   #define STAT_START_TRADE_TIME       43
#endif
#ifndef STAT_LAST_TRADE_TIME
   #define STAT_LAST_TRADE_TIME        44
#endif
#ifndef STAT_AVG_HOLD_TIME
   #define STAT_AVG_HOLD_TIME          45
#endif
#ifndef STAT_LINEAR_CORRELATION_EQUITY
   #define STAT_LINEAR_CORRELATION_EQUITY 46
#endif

#endif  // TESTERCOMPAT_MQH
// --- END inlined module: modules/TesterCompat.mqh ---

// --- BEGIN inlined module: modules/RegimeFilter.mqh ---
#ifndef __REGIME_FILTER_MQH__
#define __REGIME_FILTER_MQH__

#include <Trade\Trade.mqh>

enum RegimeBucket
{
   REGIME_LOW = 0,
   REGIME_NORMAL = 1,
   REGIME_HIGH = 2
};

class RegimeFilter
{
private:
   string            m_symbol;
   ENUM_TIMEFRAMES   m_tfH1;
   ENUM_TIMEFRAMES   m_tfH4;
   ENUM_TIMEFRAMES   m_tfD1;
   int               m_atrPeriod;
   int               m_handleH1;
   int               m_handleH4;
   int               m_handleD1;
   double            m_lowThreshold;
   double            m_highThreshold;
   double            m_lastAtrH1;
   double            m_lastAtrH4;
   double            m_lastAtrD1;
   RegimeBucket      m_currentBucket;
   datetime          m_lastUpdateBarTime;

   bool CalculatePercentiles()
   {
      const int lookback = 2000;
      double buffer[];
      ArrayResize(buffer,lookback);
      int copied = CopyBuffer(m_handleH1,0,0,lookback,buffer);
      if(copied <= 50)
         return false;
      ArrayResize(buffer,copied);
      ArraySort(buffer);
      int lowIndex  = (int)MathMax(0,MathFloor(0.30*(copied-1)));
      int highIndex = (int)MathMax(0,MathFloor(0.70*(copied-1)));
      m_lowThreshold  = buffer[lowIndex];
      m_highThreshold = buffer[highIndex];
      return true;
   }

public:
   RegimeFilter() : m_symbol(_Symbol), m_tfH1(PERIOD_H1), m_tfH4(PERIOD_H4), m_tfD1(PERIOD_D1), m_atrPeriod(14),
                    m_handleH1(INVALID_HANDLE), m_handleH4(INVALID_HANDLE), m_handleD1(INVALID_HANDLE), m_lowThreshold(0.0),
                    m_highThreshold(0.0), m_lastAtrH1(0.0), m_lastAtrH4(0.0), m_lastAtrD1(0.0),
                    m_currentBucket(REGIME_NORMAL), m_lastUpdateBarTime(0)
   {
   }

   bool Init(const string symbol,const int atrPeriod=14)
   {
      m_symbol    = symbol;
      m_atrPeriod = atrPeriod;
      m_handleH1  = iATR(m_symbol,m_tfH1,m_atrPeriod);
      m_handleH4  = iATR(m_symbol,m_tfH4,m_atrPeriod);
      m_handleD1  = iATR(m_symbol,m_tfD1,m_atrPeriod);
      if(m_handleH1==INVALID_HANDLE || m_handleH4==INVALID_HANDLE || m_handleD1==INVALID_HANDLE)
         return false;
      if(!CalculatePercentiles())
         return false;
      return Update(true);
   }

   void Release()
   {
      if(m_handleH1!=INVALID_HANDLE)
      {
         IndicatorRelease(m_handleH1);
         m_handleH1 = INVALID_HANDLE;
      }
      if(m_handleH4!=INVALID_HANDLE)
      {
         IndicatorRelease(m_handleH4);
         m_handleH4 = INVALID_HANDLE;
      }
      if(m_handleD1!=INVALID_HANDLE)
      {
         IndicatorRelease(m_handleD1);
         m_handleD1 = INVALID_HANDLE;
      }
   }

   bool Update(const bool force=false)
   {
      datetime barTime = iTime(m_symbol,m_tfH1,0);
      if(!force && barTime==m_lastUpdateBarTime)
         return true;

      double atrH1Buffer[];
      ArrayResize(atrH1Buffer,1);
      if(CopyBuffer(m_handleH1,0,0,1,atrH1Buffer)!=1)
         return false;
      double atrH4Buffer[];
      ArrayResize(atrH4Buffer,1);
      if(CopyBuffer(m_handleH4,0,0,1,atrH4Buffer)!=1)
         return false;
      double atrD1Buffer[];
      ArrayResize(atrD1Buffer,1);
      if(CopyBuffer(m_handleD1,0,0,1,atrD1Buffer)!=1)
         return false;

      double atrH1 = atrH1Buffer[0];
      double atrH4 = atrH4Buffer[0];
      double atrD1 = atrD1Buffer[0];
      m_lastAtrH1 = atrH1;
      m_lastAtrH4 = atrH4;
      m_lastAtrD1 = atrD1;
      m_lastUpdateBarTime = barTime;

      if(atrH1 <= m_lowThreshold)
         m_currentBucket = REGIME_LOW;
      else if(atrH1 >= m_highThreshold)
         m_currentBucket = REGIME_HIGH;
      else
         m_currentBucket = REGIME_NORMAL;
      return true;
   }

   RegimeBucket CurrentBucket() { return m_currentBucket; }

   double AtrH1() { return m_lastAtrH1; }
   double AtrH4() { return m_lastAtrH4; }
   double AtrD1() { return m_lastAtrD1; }
   double LowThreshold() { return m_lowThreshold; }
   double HighThreshold() { return m_highThreshold; }
};

#endif // __REGIME_FILTER_MQH__
// --- END inlined module: modules/RegimeFilter.mqh ---

// --- BEGIN inlined module: modules/SessionFilter.mqh ---
#ifndef __SESSION_FILTER_MQH__
#define __SESSION_FILTER_MQH__

enum SessionWindow
{
   SESSION_NONE = 0,
   SESSION_EDGE = 1,
   SESSION_CORE = 2
};

class SessionFilter
{
private:
   int      m_startMinutes;
   int      m_endMinutes;
   int      m_coreStart;
   int      m_coreEnd;
   bool     m_debugMode;
   bool     m_allowDebugOverride;

   int ClampMinutes(const int minutes)
   {
      int clamped = minutes;
      clamped = MathMax(0,clamped);
      clamped = MathMin(23*60+59,clamped);
      return clamped;
   }

public:
   SessionFilter(): m_debugMode(false), m_allowDebugOverride(false)
   {
      Configure(7,0,14,45);
   }

   void Configure(const int startHour,const int startMinute,const int endHour,const int endMinute)
   {
      int start = ClampMinutes(startHour*60 + startMinute);
      int end   = ClampMinutes(endHour*60 + endMinute);
      if(end<start)
         end = start;
      m_startMinutes = start;
      m_endMinutes   = end;

      int coreStart = start + 60; // default one hour after session open
      int coreEnd   = end - 180;  // default three hours before session close
      if(coreEnd<coreStart)
      {
         int mid = (start + end)/2;
         coreStart = MathMax(start,mid-60);
         coreEnd   = MathMin(end,mid+60);
      }
      m_coreStart = ClampMinutes(coreStart);
      m_coreEnd   = ClampMinutes(coreEnd);
   }

   void SetDebugMode(const bool debug,const bool allowOverride=false)
   {
      m_debugMode = debug;
      m_allowDebugOverride = allowOverride;
   }

   bool AllowsEntry(const datetime time, SessionWindow &window)
   {
      MqlDateTime dt;
      TimeToStruct(time,dt);
      if(dt.day_of_week==0 || dt.day_of_week==6)
      {
         window = SESSION_NONE;
         if(m_debugMode && m_allowDebugOverride)
         {
            PrintFormat("SESSION DEBUG: %s outside trading days (weekend) -> override due to debug",
                        TimeToString(time,TIME_DATE|TIME_MINUTES));
            window = SESSION_EDGE;
            return true;
         }
         return false;
      }
      int minutes = dt.hour*60 + dt.min;
      if(minutes < m_startMinutes || minutes > m_endMinutes)
      {
         window = SESSION_NONE;
         if(m_debugMode && m_allowDebugOverride)
         {
            PrintFormat("SESSION DEBUG: %s outside window %02d:%02d-%02d:%02d (minutes=%d) -> override due to debug",
                        TimeToString(time,TIME_DATE|TIME_MINUTES),
                        m_startMinutes/60,m_startMinutes%60,m_endMinutes/60,m_endMinutes%60,minutes);
            window = SESSION_EDGE;
            return true;
         }
         return false;
      }
      if(minutes >= m_coreStart && minutes <= m_coreEnd)
         window = SESSION_CORE;
      else
         window = SESSION_EDGE;
      if(m_debugMode)
      {
         PrintFormat("SESSION DEBUG: %s allowed (window=%s override=%s)",
                     TimeToString(time,TIME_DATE|TIME_MINUTES),
                     window==SESSION_CORE?"CORE":"EDGE",
                     (m_debugMode && m_allowDebugOverride)?"true":"false");
      }
      return true;
   }

   bool IsLateSession(const datetime time)
   {
      SessionWindow window;
      if(!AllowsEntry(time,window))
      {
         MqlDateTime dt;
         TimeToStruct(time,dt);
         if(dt.day_of_week==0 || dt.day_of_week==6)
            return true;
         int minutes = dt.hour*60 + dt.min;
         return (minutes > m_endMinutes);
      }
      return false;
   }
};

#endif // __SESSION_FILTER_MQH__
// --- END inlined module: modules/SessionFilter.mqh ---

// --- BEGIN inlined module: modules/BiasEngine.mqh ---
#ifndef __BIAS_ENGINE_MQH__
#define __BIAS_ENGINE_MQH__

#include "RegimeFilter.mqh"

enum BiasStrength
{
   BIAS_NEUTRAL = 0,
   BIAS_MODERATE = 1,
   BIAS_STRONG = 2
};

struct TrendBias
{
   int          direction;     // +1 long, -1 short, 0 neutral
   BiasStrength strength;      // qualitative confidence bucket
   double       score;         // aggregated slope score (sign adjusted)
   int          votesStrongLong;
   int          votesStrongShort;
   int          votesModerateLong;
   int          votesModerateShort;
   int          votesNearLong;
   int          votesNearShort;
   int          signH1;
   int          signH4;
   int          signD1;
   double       slopeH1;
   double       slopeH4;
   double       slopeD1;
   double       emaH1;
   double       emaH4;
   double       emaD1;
   double       thresholdH1;
   double       thresholdH4;
   double       thresholdD1;
   bool         relaxedApplied;
   bool         fallbackApplied;

   TrendBias()
   {
      direction = 0;
      strength = BIAS_NEUTRAL;
      score = 0.0;
      votesStrongLong = votesStrongShort = 0;
      votesModerateLong = votesModerateShort = 0;
      votesNearLong = votesNearShort = 0;
      signH1 = signH4 = signD1 = 0;
      slopeH1 = slopeH4 = slopeD1 = 0.0;
      emaH1 = emaH4 = emaD1 = 0.0;
      thresholdH1 = thresholdH4 = thresholdD1 = 0.0;
      relaxedApplied = false;
      fallbackApplied = false;
   }
};

class BiasEngine
{
private:
   string          m_symbol;
   int             m_handleH1;
   int             m_handleH4;
   int             m_handleD1;
   double          m_lastEmaH1;
   double          m_lastEmaH4;
   double          m_lastEmaD1;
   double          m_thH1Base;
   double          m_thH4Base;
   double          m_thD1Base;
   double          m_thresholdScale;
   double          m_lastSlopeH1;
   double          m_lastSlopeH4;
   double          m_lastSlopeD1;
   bool            m_debug;
   int             m_legacyVotesRequired;
   TrendBias       m_lastBias;

   double NormalizedSlope(const double now,const double prev,const double atr) const
   {
      if(atr<=0.0)
         return 0.0;
      return (now-prev)/atr;
   }

public:
   BiasEngine(): m_symbol(_Symbol), m_handleH1(INVALID_HANDLE), m_handleH4(INVALID_HANDLE), m_handleD1(INVALID_HANDLE),
                 m_lastEmaH1(0.0), m_lastEmaH4(0.0), m_lastEmaD1(0.0),
                 m_thH1Base(0.020), m_thH4Base(0.018), m_thD1Base(0.015), m_thresholdScale(1.0),
                 m_lastSlopeH1(0.0), m_lastSlopeH4(0.0), m_lastSlopeD1(0.0),
                 m_debug(false),
                 m_legacyVotesRequired(0)
   {
      m_lastBias = TrendBias();
   }

   bool Init(const string symbol)
   {
      m_symbol   = symbol;
      m_handleH1 = iMA(symbol,PERIOD_H1,20,0,MODE_EMA,PRICE_CLOSE);
      m_handleH4 = iMA(symbol,PERIOD_H4,34,0,MODE_EMA,PRICE_CLOSE);
      m_handleD1 = iMA(symbol,PERIOD_D1,50,0,MODE_EMA,PRICE_CLOSE);
      return (m_handleH1!=INVALID_HANDLE && m_handleH4!=INVALID_HANDLE && m_handleD1!=INVALID_HANDLE);
   }

   void Release()
   {
      if(m_handleH1!=INVALID_HANDLE)
      {
         IndicatorRelease(m_handleH1);
         m_handleH1 = INVALID_HANDLE;
      }
      if(m_handleH4!=INVALID_HANDLE)
      {
         IndicatorRelease(m_handleH4);
         m_handleH4 = INVALID_HANDLE;
      }
      if(m_handleD1!=INVALID_HANDLE)
      {
         IndicatorRelease(m_handleD1);
         m_handleD1 = INVALID_HANDLE;
      }
   }

   void ConfigureThresholds(const int votesRequired,
                            const double thH1,const double thH4,const double thD1)
   {
      m_legacyVotesRequired = votesRequired; // legacy input kept for preset compatibility
      m_thH1Base = MathMax(0.0,thH1);
      m_thH4Base = MathMax(0.0,thH4);
      m_thD1Base = MathMax(0.0,thD1);
   }

   bool Update(RegimeFilter &regime)
   {
      double e1[2];
      double e4[2];
      double eD[2];
      if(CopyBuffer(m_handleH1,0,0,2,e1)!=2)
         return false;
      if(CopyBuffer(m_handleH4,0,0,2,e4)!=2)
         return false;
      if(CopyBuffer(m_handleD1,0,0,2,eD)!=2)
         return false;

      m_lastEmaH1 = e1[0];
      m_lastEmaH4 = e4[0];
      m_lastEmaD1 = eD[0];

      double atrH1 = regime.AtrH1();
      double atrH4 = regime.AtrH4();
      double atrD1 = (regime.AtrD1()!=0.0 ? regime.AtrD1() : atrH4*2.5);

      m_lastSlopeH1 = 0.0;
      m_lastSlopeH4 = 0.0;
      m_lastSlopeD1 = 0.0;
      m_lastSlopeH1 = NormalizedSlope(e1[0],e1[1],atrH1);
      m_lastSlopeH4 = NormalizedSlope(e4[0],e4[1],atrH4);
      m_lastSlopeD1 = NormalizedSlope(eD[0],eD[1],atrD1);

      m_lastBias = TrendBias();
      return true;
   }

   double EmaH1() { return m_lastEmaH1; }
   double EmaH4() { return m_lastEmaH4; }
   double EmaD1() { return m_lastEmaD1; }

   void SetSlopeThreshold(const double multiplier)
   {
      m_thresholdScale = (multiplier>=0.0 ? multiplier : 0.0);
   }

   double SlopeH1() const { return m_lastSlopeH1; }
   double SlopeH4() const { return m_lastSlopeH4; }
   double SlopeD1() const { return m_lastSlopeD1; }
   double ThresholdH1() const { return m_thH1Base*m_thresholdScale; }
   double ThresholdH4() const { return m_thH4Base*m_thresholdScale; }
   double ThresholdD1() const { return m_thD1Base*m_thresholdScale; }

   void SetDebug(const bool debug)
   {
      m_debug = debug;
   }

   bool ComputeTrendBias(TrendBias &bias,const bool relaxedMode,const bool fallbackMode)
   {
      // Multi-timeframe classification: normalised EMA slopes (ATR-adjusted) vote per TF.
      // STRONG if >=2 TFs exceed their threshold in the same direction, MODERATE if exactly
      // one TF clears the threshold or several sit in the 0.5x-1.0x buffer, otherwise NEUTRAL.
      double scale = m_thresholdScale;
      double relaxedAdj = (relaxedMode ? 0.90 : 1.0);
      double fallbackAdj = (fallbackMode ? 0.75 : 1.0);
      double effH1 = m_thH1Base*scale*relaxedAdj*fallbackAdj;
      double effH4 = m_thH4Base*scale*relaxedAdj*fallbackAdj;
      double effD1 = m_thD1Base*scale*relaxedAdj*fallbackAdj;
      double nearH1 = effH1*0.5;
      double nearH4 = effH4*0.5;
      double nearD1 = effD1*0.5;

      bias = TrendBias();
      bias.slopeH1 = m_lastSlopeH1;
      bias.slopeH4 = m_lastSlopeH4;
      bias.slopeD1 = m_lastSlopeD1;
      bias.emaH1 = m_lastEmaH1;
      bias.emaH4 = m_lastEmaH4;
      bias.emaD1 = m_lastEmaD1;
      bias.thresholdH1 = effH1;
      bias.thresholdH4 = effH4;
      bias.thresholdD1 = effD1;
      bias.relaxedApplied = relaxedMode;
      bias.fallbackApplied = fallbackMode;

      double slopes[3] = {m_lastSlopeH1,m_lastSlopeH4,m_lastSlopeD1};
      double strongTh[3] = {effH1,effH4,effD1};
      double moderateTh[3] = {nearH1,nearH4,nearD1};

      int signs[3] = {0,0,0};
      int strongLong=0,strongShort=0;
      int moderateLong=0,moderateShort=0;
      int nearLong=0,nearShort=0;
      double posSum=0.0,negSum=0.0;

      for(int i=0;i<3;i++)
      {
         double slope = slopes[i];
         double absSlope = MathAbs(slope);
         if(absSlope < 1e-6)
         {
            signs[i] = 0;
            continue;
         }
         int sign = (slope>0.0 ? +1 : -1);
         signs[i] = sign;
         bool strong = (absSlope >= strongTh[i] && strongTh[i]>0.0);
         bool moderate = (absSlope >= moderateTh[i] && moderateTh[i]>0.0);
         if(sign>0)
         {
            if(strong) strongLong++;
            if(moderate) moderateLong++;
            if(moderate && !strong) nearLong++;
            posSum += slope;
         }
         else if(sign<0)
         {
            if(strong) strongShort++;
            if(moderate) moderateShort++;
            if(moderate && !strong) nearShort++;
            negSum += MathAbs(slope);
         }
      }

      bias.signH1 = signs[0];
      bias.signH4 = signs[1];
      bias.signD1 = signs[2];
      bias.votesStrongLong = strongLong;
      bias.votesStrongShort = strongShort;
      bias.votesModerateLong = moderateLong;
      bias.votesModerateShort = moderateShort;
      bias.votesNearLong = nearLong;
      bias.votesNearShort = nearShort;

      if(strongLong>=2 || strongShort>=2)
      {
         bias.strength = BIAS_STRONG;
         if(strongLong>strongShort)
            bias.direction = +1;
         else if(strongShort>strongLong)
            bias.direction = -1;
         else
            bias.direction = (posSum>=negSum ? +1 : -1);
      }
      else
      {
         bool longModerate=false;
         bool shortModerate=false;

         if(strongLong==1 && strongShort==0)
            longModerate = true;
         if(strongShort==1 && strongLong==0)
            shortModerate = true;
         if(!longModerate && strongLong==0 && strongShort==0 && nearLong>=2 && moderateLong>=2)
            longModerate = true;
         if(!shortModerate && strongLong==0 && strongShort==0 && nearShort>=2 && moderateShort>=2)
            shortModerate = true;

         if(longModerate && !shortModerate)
         {
            bias.direction = +1;
            bias.strength = BIAS_MODERATE;
         }
         else if(shortModerate && !longModerate)
         {
            bias.direction = -1;
            bias.strength = BIAS_MODERATE;
         }
         else
         {
            bias.direction = 0;
            bias.strength = BIAS_NEUTRAL;
         }
      }

      if(bias.direction>0)
         bias.score = posSum;
      else if(bias.direction<0)
         bias.score = -negSum;
      else
         bias.score = 0.0;

      m_lastBias = bias;

      if(m_debug)
      {
         PrintFormat("BIAS DEBUG: slopes=H1 %.4f H4 %.4f D1 %.4f | strongVotes L%d/S%d moderateVotes L%d/S%d nearVotes L%d/S%d -> dir=%d strength=%d score=%.4f relaxed=%s fallback=%s",
                     m_lastSlopeH1,m_lastSlopeH4,m_lastSlopeD1,
                     strongLong,strongShort,
                     moderateLong,moderateShort,
                     nearLong,nearShort,
                     bias.direction,(int)bias.strength,bias.score,
                     relaxedMode?"true":"false",
                     fallbackMode?"true":"false");
      }
      return true;
   }

   TrendBias LastBias() const
   {
      return m_lastBias;
   }
};

#endif // __BIAS_ENGINE_MQH__
// --- END inlined module: modules/BiasEngine.mqh ---

// --- BEGIN inlined module: modules/EntryEngine.mqh ---
#ifndef __ENTRY_ENGINE_MQH__
#define __ENTRY_ENGINE_MQH__

#include "BiasEngine.mqh"
#include "SessionFilter.mqh"

enum EntryFamily
{
   ENTRY_FAMILY_NONE = -1,
   ENTRY_FAMILY_PULLBACK = 0,
   ENTRY_FAMILY_BREAKOUT = 1
};

struct EntrySignal
{
   bool          valid;
   int           direction;
   double        entryPrice;
   double        stopLoss;
   double        atr;
   EntryFamily   family;
   SessionWindow session;
   RegimeBucket  regime;
   bool          fallbackRelaxed;
   double        quality;
   BiasStrength  biasStrength;
   bool          strongSetup;
   double        riskScale;
   int           biasDirection;
   double        biasScore;
   double        biasSlopeH1;
   double        biasSlopeH4;
   double        biasSlopeD1;

   EntrySignal()
   {
      valid = false;
      direction = 0;
      entryPrice = 0.0;
      stopLoss = 0.0;
      atr = 0.0;
      family = ENTRY_FAMILY_NONE;
      session = SESSION_NONE;
      regime = REGIME_NORMAL;
      fallbackRelaxed = false;
      quality = 0.0;
      biasStrength = BIAS_NEUTRAL;
      strongSetup = false;
      riskScale = 1.0;
      biasDirection = 0;
      biasScore = 0.0;
      biasSlopeH1 = 0.0;
      biasSlopeH4 = 0.0;
      biasSlopeD1 = 0.0;
   }
};

struct PullbackEvaluation
{
   bool   touched;
   bool   closeOk;
   bool   structureOk;
   bool   wickSupport;
   bool   momentumOk;
   double bodyAtrRatio;
   double momentumThreshold;
   double touchScore;
   double closeScore;
   double momentumScore;
   double structureScore;
   double wickScore;
   double quality;
   bool   strong;

   PullbackEvaluation()
   {
      touched = closeOk = structureOk = wickSupport = momentumOk = false;
      bodyAtrRatio = momentumThreshold = 0.0;
      touchScore = closeScore = momentumScore = structureScore = wickScore = 0.0;
      quality = 0.0;
      strong = false;
   }
};

struct BreakoutEvaluation
{
   bool   boxOk;
   bool   impulseOk;
   bool   clearedLevel;
   bool   madeExtreme;
   double boxSize;
   double minBoxMult;
   double maxBoxMult;
   double impulseThreshold;
   double bodyAtrRatio;
   double boxScore;
   double impulseScore;
   double breakoutScore;
   double quality;
   bool   strong;

   BreakoutEvaluation()
   {
      boxOk = impulseOk = clearedLevel = madeExtreme = false;
      boxSize = minBoxMult = maxBoxMult = impulseThreshold = bodyAtrRatio = 0.0;
      boxScore = impulseScore = breakoutScore = 0.0;
      quality = 0.0;
      strong = false;
   }
};

class EntryEngine
{
private:
   double m_slAtrMult;
   bool   m_randomize;
   double m_pullbackBodyAtrMin;
   double m_breakoutImpulseAtrMin;
   int    m_breakoutRangeBars;
   double m_minQualityCoreLong;
   double m_minQualityCoreShort;
   double m_minQualityEdgeLong;
   double m_minQualityEdgeShort;
   bool   m_allowAggressiveEntries;
   double m_aggressiveDiscount;
   double m_aggressiveFloor;
   bool   m_allowNeutralBiasEdge;
   double m_neutralBiasRiskScale;
   bool   m_allowLongs;
   bool   m_allowShorts;
   double m_qualityBoostLowRegime;
   double m_qualityBoostHighRegime;
   double m_lowRegimeRiskScale;
   double m_highRegimeRiskScale;
   bool   m_requireStrongFallback;
   double m_fallbackRiskScale;

   double BaseQualityFor(const SessionWindow session,const int direction,const bool fallbackMode) const
   {
      bool useCore = (session==SESSION_CORE);
      if(fallbackMode && session!=SESSION_CORE)
         useCore = false;

      if(direction>0)
         return (useCore ? m_minQualityCoreLong : m_minQualityEdgeLong);
      if(direction<0)
         return (useCore ? m_minQualityCoreShort : m_minQualityEdgeShort);
      double bothCore = MathMin(m_minQualityCoreLong,m_minQualityCoreShort);
      double bothEdge = MathMin(m_minQualityEdgeLong,m_minQualityEdgeShort);
      return (useCore ? bothCore : bothEdge);
   }

   double ScoreFromProximity(const double distance,const double scale) const
   {
      if(scale<=0.0)
         return 0.0;
      double ratio = MathMax(0.0,1.0 - MathAbs(distance)/(scale+1e-9));
      return MathMax(0.0,MathMin(1.0,ratio));
   }

   double EvaluatePullbackQuality(const int direction,const MqlRates &barPrev,const MqlRates &barPrev2,
                                  const double ema,const double atr,const bool relaxedMomentum,
                                  const RegimeBucket bucket,const bool verbose,PullbackEvaluation &out) const
   {
      out = PullbackEvaluation();
      if(atr<=0.0)
         return 0.0;

      double momentumThreshold = m_pullbackBodyAtrMin;
      if(bucket==REGIME_LOW)
         momentumThreshold *= 0.85;
      else if(bucket==REGIME_HIGH)
         momentumThreshold *= 1.10;
      if(relaxedMomentum)
         momentumThreshold *= 0.75;
      out.momentumThreshold = momentumThreshold;

      double body = MathAbs(barPrev.close-barPrev.open);
      out.bodyAtrRatio = (atr>0.0 ? body/atr : 0.0);
      out.momentumOk = (out.bodyAtrRatio >= momentumThreshold) || relaxedMomentum;
      out.momentumScore = MathMin(1.0,(momentumThreshold>0.0 ? out.bodyAtrRatio/(momentumThreshold+1e-9) : 0.0));
      out.momentumScore = MathMax(0.0,MathMin(1.0,out.momentumScore));

      double band = 0.45*atr;
      double tolerance = (relaxedMomentum ? 0.18 : 0.08)*atr;
      double distance = 0.0;

      if(direction>0)
      {
         distance = (ema-band) - barPrev.low;
         out.touched = (barPrev.low <= ema-band);
         if(!out.touched && relaxedMomentum)
            out.touched = (barPrev.low <= ema-0.10*atr);
         out.closeOk = (barPrev.close >= ema - tolerance);
         bool priorDown = (barPrev2.close < barPrev2.open);
         out.wickSupport = (barPrev.low <= ema - 0.25*atr);
         out.structureOk = (priorDown || out.wickSupport || relaxedMomentum);
      }
      else if(direction<0)
      {
         distance = barPrev.high - (ema+band);
         out.touched = (barPrev.high >= ema+band);
         if(!out.touched && relaxedMomentum)
            out.touched = (barPrev.high >= ema+0.10*atr);
         out.closeOk = (barPrev.close <= ema + tolerance);
         bool priorUp = (barPrev2.close > barPrev2.open);
         out.wickSupport = (barPrev.high >= ema + 0.25*atr);
         out.structureOk = (priorUp || out.wickSupport || relaxedMomentum);
      }

      out.touchScore = (out.touched ? 1.0 : ScoreFromProximity(distance,0.6*atr));
      double closeDistance = MathAbs(barPrev.close-ema);
      out.closeScore = (out.closeOk ? 1.0 : ScoreFromProximity(closeDistance,tolerance+0.25*atr));
      out.structureScore = (out.structureOk ? 1.0 : 0.0);
      out.wickScore = (out.wickSupport ? 1.0 : 0.0);

      double quality = 0.30*out.touchScore + 0.20*out.closeScore + 0.25*out.momentumScore + 0.15*out.structureScore + 0.10*out.wickScore;
      out.quality = MathMax(0.0,MathMin(1.0,quality));
      out.strong = (out.touched && out.closeOk && out.structureOk && out.momentumOk && out.bodyAtrRatio >= momentumThreshold*1.15);
      if(!out.strong && out.quality>=0.90)
         out.strong = true;

      if(verbose)
      {
         PrintFormat("ENTRY TRACE: pullback dir=%d touched=%s closeOk=%s structureOk=%s momentumOk=%s bodyATR=%.2f th=%.2f quality=%.2f strong=%s",
                     direction,
                     out.touched?"true":"false",
                     out.closeOk?"true":"false",
                     out.structureOk?"true":"false",
                     out.momentumOk?"true":"false",
                     out.bodyAtrRatio,
                     out.momentumThreshold,
                     out.quality,
                     out.strong?"true":"false");
      }
      return out.quality;
   }

   double EvaluateBreakoutQuality(const int direction,MqlRates &bars[],const int count,const double atr,
                                  const SessionWindow window,const bool relaxedMomentum,const RegimeBucket bucket,
                                  const bool verbose,BreakoutEvaluation &out) const
   {
      out = BreakoutEvaluation();
      if(atr<=0.0)
         return 0.0;

      int lookback = MathMax(4,m_breakoutRangeBars);
      if(count<lookback+2 || window==SESSION_NONE)
         return 0.0;

      MqlRates barPrev = bars[1];
      double rangeHigh = -DBL_MAX;
      double rangeLow  = DBL_MAX;
      int maxIndex = MathMin(count-1,1+lookback);
      for(int i=2;i<=maxIndex;i++)
      {
         rangeHigh = MathMax(rangeHigh,bars[i].high);
         rangeLow  = MathMin(rangeLow,bars[i].low);
      }
      double box = rangeHigh - rangeLow;
      out.boxSize = box;

      double minBoxMult = 0.15;
      double maxBoxMult = 1.0;
      if(bucket==REGIME_LOW)
         maxBoxMult *= 1.25;
      else if(bucket==REGIME_HIGH)
         maxBoxMult *= 0.85;
      if(relaxedMomentum)
         maxBoxMult *= 1.15;
      out.minBoxMult = minBoxMult;
      out.maxBoxMult = maxBoxMult;

      out.boxOk = (box>atr*minBoxMult && box<=atr*maxBoxMult);
      if(atr>0.0)
      {
         double norm = box/atr;
         double target = (minBoxMult+maxBoxMult)/2.0;
         double span = MathMax(0.05,(maxBoxMult-minBoxMult)/2.0);
         out.boxScore = MathMax(0.0,1.0 - MathAbs(norm-target)/(span+1e-9));
      }

      double impulseMult = m_breakoutImpulseAtrMin;
      if(bucket==REGIME_LOW)
         impulseMult *= (0.33/0.35);
      else if(bucket==REGIME_HIGH)
         impulseMult *= (0.40/0.35);
      out.impulseThreshold = impulseMult;

      double body = MathAbs(barPrev.close-barPrev.open);
      out.bodyAtrRatio = (atr>0.0 ? body/atr : 0.0);
      out.impulseOk = (body >= impulseMult*atr);
      if(relaxedMomentum)
         out.impulseOk = (body >= 0.25*atr);
      out.impulseScore = MathMin(1.0,(impulseMult>0.0 ? out.bodyAtrRatio/(impulseMult+1e-9) : 0.0));
      out.impulseScore = MathMax(0.0,MathMin(1.0,out.impulseScore));

      double breakoutBuffer = (relaxedMomentum ? 0.10 : 0.02)*atr;
      if(direction>0)
      {
         out.clearedLevel = (barPrev.close >= rangeHigh - breakoutBuffer);
         out.madeExtreme = (barPrev.high >= rangeHigh);
      }
      else if(direction<0)
      {
         out.clearedLevel = (barPrev.close <= rangeLow + breakoutBuffer);
         out.madeExtreme = (barPrev.low <= rangeLow);
      }

      out.breakoutScore = (out.clearedLevel && out.madeExtreme ? 1.0 : (out.clearedLevel || out.madeExtreme ? 0.6 : 0.0));
      double quality = 0.35*out.boxScore + 0.35*out.impulseScore + 0.30*out.breakoutScore;
      out.quality = MathMax(0.0,MathMin(1.0,quality));
      out.strong = (out.boxOk && out.impulseOk && out.clearedLevel && out.madeExtreme && out.bodyAtrRatio >= impulseMult*1.10);
      if(!out.strong && out.quality>=0.90)
         out.strong = true;

      if(verbose)
      {
         PrintFormat("ENTRY TRACE: breakout dir=%d box=%.2f atr=%.2f boxOk=%s impulseOk=%s cleared=%s newExtreme=%s quality=%.2f strong=%s",
                     direction,
                     box,
                     atr,
                     out.boxOk?"true":"false",
                     out.impulseOk?"true":"false",
                     out.clearedLevel?"true":"false",
                     out.madeExtreme?"true":"false",
                     out.quality,
                     out.strong?"true":"false");
      }
      return out.quality;
   }

   bool SelectBestSignal(const int direction,const double atr,const TrendBias &bias,const SessionWindow session,
                         const bool relaxedMomentum,const bool verbose,const double minQuality,
                         MqlRates &bars[],const int count,EntrySignal &signal) const
   {
      MqlRates barPrev = bars[1];
      MqlRates barPrev2 = bars[2];
      PullbackEvaluation pullEval;
      BreakoutEvaluation breakEval;
      double pullQuality = EvaluatePullbackQuality(direction,barPrev,barPrev2,bias.emaH1,atr,relaxedMomentum,signal.regime,verbose,pullEval);
      double breakQuality = EvaluateBreakoutQuality(direction,bars,count,atr,session,relaxedMomentum,signal.regime,verbose,breakEval);

      double bestQuality = 0.0;
      EntryFamily bestFamily = ENTRY_FAMILY_NONE;
      bool strongSetup = false;

      if(pullQuality>=breakQuality)
      {
         bestQuality = pullQuality;
         bestFamily = (pullQuality>0.0 ? ENTRY_FAMILY_PULLBACK : ENTRY_FAMILY_NONE);
         strongSetup = pullEval.strong;
      }
      else
      {
         bestQuality = breakQuality;
         bestFamily = (breakQuality>0.0 ? ENTRY_FAMILY_BREAKOUT : ENTRY_FAMILY_NONE);
         strongSetup = breakEval.strong;
      }

      if(bestFamily==ENTRY_FAMILY_NONE || bestQuality<minQuality)
      {
         if(verbose)
         {
            PrintFormat("ENTRY TRACE: bestQuality=%.2f below threshold %.2f (family=%d)",bestQuality,minQuality,(int)bestFamily);
         }
         return false;
      }

      signal.family = bestFamily;
      signal.direction = direction;
      signal.quality = bestQuality;
      signal.strongSetup = strongSetup;

      double entryPrice = (direction>0 ? SymbolInfoDouble(_Symbol,SYMBOL_ASK) : SymbolInfoDouble(_Symbol,SYMBOL_BID));
      if(m_randomize)
      {
         int seed = (int)(TimeCurrent()%100000);
         MathSrand(seed);
         double jitter = 0.1*atr*((double)MathRand()/32767.0-0.5);
         entryPrice += (direction>0 ? jitter : -jitter);
      }
      signal.entryPrice = entryPrice;
      signal.stopLoss = entryPrice - direction*m_slAtrMult*atr;
      signal.atr = atr;
      signal.valid = true;
      return true;
   }

public:
   EntryEngine(): m_slAtrMult(1.2), m_randomize(false),
                  m_pullbackBodyAtrMin(0.35), m_breakoutImpulseAtrMin(0.35), m_breakoutRangeBars(5),
                  m_minQualityCoreLong(0.70), m_minQualityCoreShort(0.70),
                  m_minQualityEdgeLong(0.80), m_minQualityEdgeShort(0.80),
                  m_allowAggressiveEntries(true), m_aggressiveDiscount(0.05), m_aggressiveFloor(0.60),
                  m_allowNeutralBiasEdge(true), m_neutralBiasRiskScale(0.5),
                  m_allowLongs(true), m_allowShorts(true),
                  m_qualityBoostLowRegime(0.05), m_qualityBoostHighRegime(0.02),
                  m_lowRegimeRiskScale(0.75), m_highRegimeRiskScale(1.0),
                  m_requireStrongFallback(true), m_fallbackRiskScale(1.0)
   {
   }

   void Configure(const bool randomize)
   {
      m_randomize = randomize;
   }

   void SetStopMultiplier(const double slMult)
   {
      if(slMult>0.0)
         m_slAtrMult = slMult;
   }

   void ConfigureSensitivity(const double pullbackBodyAtrMin,const double breakoutImpulseAtrMin,const int breakoutRangeBars)
   {
      if(pullbackBodyAtrMin>0.0)
         m_pullbackBodyAtrMin = pullbackBodyAtrMin;
      if(breakoutImpulseAtrMin>0.0)
         m_breakoutImpulseAtrMin = breakoutImpulseAtrMin;
      if(breakoutRangeBars>=4)
         m_breakoutRangeBars = breakoutRangeBars;
   }

   void SetQualityThresholds(const double minCoreLong,const double minCoreShort,
                             const double minEdgeLong,const double minEdgeShort,
                             const bool allowAggressive,const double aggressiveDiscount,const double aggressiveFloor)
   {
      if(minCoreLong>0.0)
         m_minQualityCoreLong = MathMin(0.95,minCoreLong);
      if(minCoreShort>0.0)
         m_minQualityCoreShort = MathMin(0.95,minCoreShort);
      if(minEdgeLong>0.0)
         m_minQualityEdgeLong = MathMin(0.95,minEdgeLong);
      if(minEdgeShort>0.0)
         m_minQualityEdgeShort = MathMin(0.95,minEdgeShort);
      m_allowAggressiveEntries = allowAggressive;
      if(aggressiveDiscount>=0.0)
         m_aggressiveDiscount = aggressiveDiscount;
      if(aggressiveFloor>0.0)
         m_aggressiveFloor = aggressiveFloor;
   }

   void SetDirectionalPermissions(const bool allowLongs,const bool allowShorts)
   {
      m_allowLongs = allowLongs;
      m_allowShorts = allowShorts;
   }

   void ConfigureNeutralPolicy(const bool allowNeutralEdge,const double neutralRiskScale)
   {
      m_allowNeutralBiasEdge = allowNeutralEdge;
      m_neutralBiasRiskScale = MathMax(0.0,MathMin(1.0,neutralRiskScale));
   }

   void ConfigureRegimeAdjustments(const double lowQualityBoost,const double highQualityBoost,
                                   const double lowRiskScale,const double highRiskScale)
   {
      m_qualityBoostLowRegime = MathMax(0.0,MathMin(0.20,lowQualityBoost));
      m_qualityBoostHighRegime = MathMax(0.0,MathMin(0.15,highQualityBoost));
      double lowScale = (lowRiskScale<=0.0 ? 0.0 : lowRiskScale);
      double highScale = (highRiskScale<=0.0 ? 0.0 : highRiskScale);
      m_lowRegimeRiskScale = MathMax(0.2,MathMin(1.0,lowScale));
      m_highRegimeRiskScale = MathMax(0.2,MathMin(1.2,highScale));
   }

   void SetFallbackPolicy(const bool requireStrongSetups,const double fallbackRiskScale)
   {
      m_requireStrongFallback = requireStrongSetups;
      double scale = fallbackRiskScale;
      if(scale<=0.0)
         scale = 0.0;
      if(scale>1.0)
         scale = 1.0;
      m_fallbackRiskScale = scale;
   }

   bool Evaluate(const TrendBias &bias,RegimeFilter &regime,const SessionWindow session,MqlRates &bars[],const int count,
                 const bool relaxedMomentum,const bool fallbackMode,const bool verbose,const bool allowAggressiveBoost,
                 EntrySignal &signal)
   {
      // Score-driven entry filter: pullbacks/breakouts return 0..1 quality metrics so we can
      // relax/ tighten trade frequency via MinEntryQuality inputs and aggressive-mode offsets.
      signal = EntrySignal();
      signal.session = session;
      signal.regime = regime.CurrentBucket();
      signal.fallbackRelaxed = relaxedMomentum;
      signal.biasStrength = bias.strength;

      if(count<3)
      {
         if(verbose)
            Print("ENTRY TRACE: abort -> insufficient bars for evaluation");
         return false;
      }

      double atr = regime.AtrH1();
      if(atr<=0.0)
      {
         if(verbose)
            PrintFormat("ENTRY TRACE: abort -> invalid ATR %.5f",atr);
         return false;
      }

      double baseQualityLong = BaseQualityFor(session,+1,fallbackMode);
      double baseQualityShort = BaseQualityFor(session,-1,fallbackMode);
      double minQualityLong = baseQualityLong;
      double minQualityShort = baseQualityShort;
      bool aggressiveApplied = false;
      if(m_allowAggressiveEntries && allowAggressiveBoost && bias.strength==BIAS_STRONG)
      {
         minQualityLong = MathMax(m_aggressiveFloor,minQualityLong - m_aggressiveDiscount);
         minQualityShort = MathMax(m_aggressiveFloor,minQualityShort - m_aggressiveDiscount);
         aggressiveApplied = true;
         if(verbose)
         {
            PrintFormat("ENTRY TRACE: aggressive mode -> minQuality adjusted (long=%.2f short=%.2f)",
                        minQualityLong,minQualityShort);
         }
      }

      bool allowModerate = fallbackMode;
      bool allowNeutral = (m_allowNeutralBiasEdge && (session==SESSION_EDGE || fallbackMode));

      double regimeQualityBoost = 0.0;
      if(signal.regime==REGIME_LOW)
         regimeQualityBoost = m_qualityBoostLowRegime;
      else if(signal.regime==REGIME_HIGH)
         regimeQualityBoost = m_qualityBoostHighRegime;

      if(regimeQualityBoost>0.0)
      {
         minQualityLong = MathMin(0.99,minQualityLong + regimeQualityBoost);
         minQualityShort = MathMin(0.99,minQualityShort + regimeQualityBoost);
      }

      int evalDirection = bias.direction;
      BiasStrength activeStrength = bias.strength;

      if(activeStrength==BIAS_STRONG && evalDirection==0)
      {
         activeStrength = BIAS_NEUTRAL;
      }

      if(activeStrength==BIAS_NEUTRAL)
      {
         if(!allowNeutral)
         {
            if(verbose)
               Print("ENTRY TRACE: abort -> bias neutral and neutral trades disabled");
            return false;
         }
      }
      else if(activeStrength==BIAS_MODERATE)
      {
         if(!allowModerate)
         {
            if(verbose)
               PrintFormat("ENTRY TRACE: abort -> bias moderate but fallbackMode=%s",fallbackMode?"true":"false");
            return false;
         }
      }
      else if(activeStrength==BIAS_STRONG && evalDirection==0)
      {
         if(verbose)
            Print("ENTRY TRACE: abort -> bias strong but direction unresolved");
         return false;
      }

      bool neutralMode = (activeStrength==BIAS_NEUTRAL || evalDirection==0);
      bool produced = false;

      signal.biasDirection = bias.direction;
      signal.biasScore = bias.score;
      signal.biasSlopeH1 = bias.slopeH1;
      signal.biasSlopeH4 = bias.slopeH4;
      signal.biasSlopeD1 = bias.slopeD1;

      if(neutralMode)
      {
         double bestQuality = -1.0;
         EntrySignal candidate;
         int dirs[2] = {+1,-1};
         for(int i=0;i<2;i++)
         {
            EntrySignal temp = signal;
            if(dirs[i]>0 && !m_allowLongs)
               continue;
            if(dirs[i]<0 && !m_allowShorts)
               continue;
            double minQuality = (dirs[i]>0 ? minQualityLong : minQualityShort);
            if(!SelectBestSignal(dirs[i],atr,bias,session,relaxedMomentum,verbose,minQuality,bars,count,temp))
               continue;
            if(!temp.strongSetup)
            {
               if(verbose)
                  PrintFormat("ENTRY TRACE: neutral bias -> rejecting direction %d due to non-strong setup",dirs[i]);
               continue;
            }
            if(temp.quality>bestQuality)
            {
               bestQuality = temp.quality;
               candidate = temp;
            }
         }
         if(bestQuality>0.0)
         {
            candidate.biasStrength = BIAS_NEUTRAL;
            candidate.riskScale = (m_neutralBiasRiskScale>0.0 ? m_neutralBiasRiskScale : 0.0);
            if(candidate.regime==REGIME_LOW)
               candidate.riskScale *= m_lowRegimeRiskScale;
            else if(candidate.regime==REGIME_HIGH)
               candidate.riskScale *= m_highRegimeRiskScale;
            signal = candidate;
            produced = candidate.riskScale>0.0;
            if(produced && verbose)
            {
               PrintFormat("ENTRY TRACE: neutral bias override -> direction=%d quality=%.2f riskScale=%.2f",
                           signal.direction,signal.quality,signal.riskScale);
            }
         }
         else if(verbose)
         {
            Print("ENTRY TRACE: neutral bias -> no qualifying strong setup");
         }
      }
      else
      {
         int direction = (evalDirection!=0 ? evalDirection : (bias.score>=0.0 ? +1 : -1));
         if(direction>0 && !m_allowLongs)
         {
            if(verbose)
               Print("ENTRY TRACE: abort -> long setups disabled");
            return false;
         }
         if(direction<0 && !m_allowShorts)
         {
            if(verbose)
               Print("ENTRY TRACE: abort -> short setups disabled");
            return false;
         }
         double minQuality = (direction>0 ? minQualityLong : minQualityShort);
         double baseQuality = (direction>0 ? baseQualityLong : baseQualityShort);
         if(SelectBestSignal(direction,atr,bias,session,relaxedMomentum,verbose,minQuality,bars,count,signal))
         {
            signal.biasStrength = activeStrength;
            signal.riskScale = 1.0;
            if(signal.regime==REGIME_LOW)
               signal.riskScale *= m_lowRegimeRiskScale;
            else if(signal.regime==REGIME_HIGH)
               signal.riskScale *= m_highRegimeRiskScale;
            if(aggressiveApplied && signal.family!=ENTRY_FAMILY_PULLBACK && signal.quality<baseQuality)
            {
               if(verbose)
                  Print("ENTRY TRACE: breakout quality below base threshold when aggressive boost was pullback-only");
               produced = false;
            }
            else
               produced = true;
         }
         else if(verbose)
         {
            Print("ENTRY TRACE: no entry pattern met the quality threshold in bias direction");
         }
      }

      if(!produced)
         return false;

      if(fallbackMode && m_requireStrongFallback && !signal.strongSetup)
      {
         if(verbose)
            Print("ENTRY TRACE: fallback mode requires strong setup -> rejecting");
         return false;
      }

      if(fallbackMode && m_fallbackRiskScale>0.0 && m_fallbackRiskScale<1.0)
      {
         signal.riskScale *= m_fallbackRiskScale;
         if(verbose)
         {
            PrintFormat("ENTRY TRACE: fallback risk scale applied -> %.2f",signal.riskScale);
         }
      }

      signal.valid = true;
      return true;
   }

   double StopMultiplier() const { return m_slAtrMult; }
};

#endif // __ENTRY_ENGINE_MQH__
// --- END inlined module: modules/EntryEngine.mqh ---

// --- BEGIN inlined module: modules/Sizer.mqh ---
#ifndef __SIZER_MQH__
#define __SIZER_MQH__

enum RiskMode
{
   RISK_FIXED_LOTS = 0,
   RISK_PERCENT_PER_TRADE = 1
};

struct SymbolContext
{
   double tickSize;
   double tickValue;
   double point;
   double contractSize;
   double lotStep;
   double minLot;
   double maxLot;
};

class PositionSizer
{
private:
   SymbolContext m_ctx;

public:
   bool Init(const string symbol)
   {
      ZeroMemory(m_ctx);
      if(!SymbolInfoDouble(symbol,SYMBOL_TRADE_TICK_SIZE,m_ctx.tickSize)) return false;
      if(!SymbolInfoDouble(symbol,SYMBOL_TRADE_TICK_VALUE,m_ctx.tickValue)) return false;
      if(!SymbolInfoDouble(symbol,SYMBOL_POINT,m_ctx.point)) return false;
      if(!SymbolInfoDouble(symbol,SYMBOL_TRADE_CONTRACT_SIZE,m_ctx.contractSize)) return false;
      if(!SymbolInfoDouble(symbol,SYMBOL_VOLUME_STEP,m_ctx.lotStep)) return false;
      if(!SymbolInfoDouble(symbol,SYMBOL_VOLUME_MIN,m_ctx.minLot)) return false;
      if(!SymbolInfoDouble(symbol,SYMBOL_VOLUME_MAX,m_ctx.maxLot)) return false;
      return true;
   }

   double NormalizeVolume(const double volume)
   {
      double lots = MathFloor(volume/m_ctx.lotStep+0.5)*m_ctx.lotStep;
      lots = MathMax(m_ctx.minLot,MathMin(m_ctx.maxLot,lots));
      return lots;
   }

   double StopDistancePoints(const double entry,const double stop)
   {
      return MathAbs(entry-stop)/m_ctx.point;
   }

   double PipValuePerLot()
   {
      if(m_ctx.point<=0.0)
         return 0.0;
      return (m_ctx.tickValue/m_ctx.tickSize)*m_ctx.point;
   }

   double CalculateVolume(const RiskMode mode,const double riskSetting,const double stopPoints,const double balance,const double riskAdjustment=1.0)
   {
      if(stopPoints<=0.0)
         return 0.0;
      double volume=0.0;
      if(mode==RISK_FIXED_LOTS)
      {
         volume = riskSetting*riskAdjustment;
      }
      else
      {
         double riskPercent = riskSetting*riskAdjustment;
         double riskAmount  = balance * (riskPercent/100.0);
         double perLotLoss  = stopPoints * PipValuePerLot();
         if(perLotLoss<=0.0)
            return 0.0;
         volume = riskAmount / perLotLoss;
      }
      return NormalizeVolume(volume);
   }

   SymbolContext Context() { return m_ctx; }
};

#endif // __SIZER_MQH__
// --- END inlined module: modules/Sizer.mqh ---

// --- BEGIN inlined module: modules/BrokerUtils.mqh ---
#ifndef __BROKER_UTILS_MQH__
#define __BROKER_UTILS_MQH__

#include <Trade\Trade.mqh>

#ifndef ERR_REQUOTE
   #define ERR_REQUOTE 138
#endif

#ifndef ERR_OFF_QUOTES
   #define ERR_OFF_QUOTES 136
#endif

#ifndef ERR_PRICE_CHANGED
   #define ERR_PRICE_CHANGED 135
#endif

class BrokerUtils
{
private:
   CTrade m_trade;
   ulong  m_magic;
   string m_comment;
   double m_slippage;

public:
   BrokerUtils(): m_magic(0), m_comment(""), m_slippage(20.0)
   {
      m_trade.SetTypeFilling(ORDER_FILLING_FOK);
      m_trade.SetAsyncMode(false);
   }

   void Configure(const ulong magic,const string comment,const double deviationPoints)
   {
      m_magic   = magic;
      m_comment = comment;
      m_slippage = deviationPoints;
      m_trade.SetExpertMagicNumber(m_magic);
      m_trade.SetDeviationInPoints((int)m_slippage);
   }

   bool OpenPosition(const int direction,const double volume,const double price,const double sl,const double tp)
   {
      if(volume<=0.0)
         return false;
      ENUM_ORDER_TYPE type;
      if(direction>0)
         type = ORDER_TYPE_BUY;
      else if(direction<0)
         type = ORDER_TYPE_SELL;
      else
         return false;
      for(int attempt=0; attempt<3; ++attempt)
      {
         ResetLastError();
         bool ok = m_trade.PositionOpen(_Symbol,type,volume,price,sl,tp,m_comment);
         if(ok)
            return true;
         int err = GetLastError();
         if(err==ERR_REQUOTE || err==ERR_OFF_QUOTES || err==ERR_PRICE_CHANGED)
         {
            Sleep(200*(attempt+1));
            MqlTick tick;
            SymbolInfoTick(_Symbol,tick);
            continue;
         }
         break;
      }
      return false;
   }

   bool ModifySL(const ulong ticket,const double sl)
   {
      if(!PositionSelectByTicket(ticket))
         return false;
      double price = PositionGetDouble(POSITION_PRICE_OPEN);
      double volume = PositionGetDouble(POSITION_VOLUME);
      double tp = PositionGetDouble(POSITION_TP);
      ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      if(type==POSITION_TYPE_BUY)
         return m_trade.PositionModify(ticket,sl,tp);
      else if(type==POSITION_TYPE_SELL)
         return m_trade.PositionModify(ticket,sl,tp);
      return false;
   }

   bool ClosePartial(const ulong ticket,const double volume)
   {
      if(volume<=0.0)
         return false;
      if(!PositionSelectByTicket(ticket))
         return false;
      return m_trade.PositionClosePartial(ticket,volume);
   }

   bool ClosePosition(const ulong ticket)
   {
      if(!PositionSelectByTicket(ticket))
         return false;
      return m_trade.PositionClose(ticket);
   }
};

#endif // __BROKER_UTILS_MQH__
// --- END inlined module: modules/BrokerUtils.mqh ---

// --- BEGIN inlined module: modules/RiskEngine.mqh ---
#ifndef __RISK_ENGINE_MQH__
#define __RISK_ENGINE_MQH__

#include "DailyGuard.mqh"
#include "Sizer.mqh"
#include "RegimeFilter.mqh"

class RiskEngine
{
private:
   DailyGuard  m_dailyGuard;
   double      m_maxEquityDDPercent;
   double      m_equityPeak;
   double      m_initialEquity;
   RiskMode    m_riskMode;
   double      m_riskSetting;
   bool        m_useDynamicRisk;
   double      m_lowFactor;
   double      m_normalFactor;
   double      m_highFactor;
   int         m_dayStartHour;
   string      m_persistKey;
   bool        m_useStaticOverallDD;
   double      m_slippageBudgetPts;
   bool        m_debugMode;
   bool        m_verboseMode;
   bool        m_killSwitchLatched;

public:
   RiskEngine(): m_maxEquityDDPercent(12.0), m_equityPeak(0.0), m_initialEquity(0.0),
                 m_riskMode(RISK_PERCENT_PER_TRADE), m_riskSetting(0.5),
                 m_useDynamicRisk(false), m_lowFactor(0.8), m_normalFactor(1.0), m_highFactor(1.2),
                 m_dayStartHour(0), m_persistKey(""), m_useStaticOverallDD(false), m_slippageBudgetPts(0.0),
                 m_debugMode(false), m_verboseMode(false), m_killSwitchLatched(false)
   {
   }

   void Configure(const RiskMode mode,const double riskSetting,const double maxDailyRisk,const double maxEquityDD,
                  const int dayStartHour,const string persistKey,const bool staticOverallDD,const double slippageBudgetPts)
   {
      m_riskMode = mode;
      m_riskSetting = riskSetting;
      m_maxEquityDDPercent = maxEquityDD;
      m_dayStartHour = dayStartHour;
      m_persistKey = persistKey;
      m_useStaticOverallDD = staticOverallDD;
      m_slippageBudgetPts = MathMax(0.0,slippageBudgetPts);
      m_dailyGuard.Configure(maxDailyRisk,dayStartHour,persistKey);
      double equity = AccountInfoDouble(ACCOUNT_EQUITY);
      m_equityPeak = equity;
      m_killSwitchLatched = false;
      if(m_persistKey!="")
      {
         string initKey = m_persistKey+"_INIT";
         if(GlobalVariableCheck(initKey))
            m_initialEquity = GlobalVariableGet(initKey);
         if(m_initialEquity<=0.0)
            m_initialEquity = equity;
         GlobalVariableSet(initKey,m_initialEquity);
      }
      else
      {
         m_initialEquity = equity;
      }
      m_dailyGuard.Heartbeat(TimeCurrent(),equity);
   }

   void OnNewDay()
   {
      m_dailyGuard.Heartbeat(TimeCurrent(),AccountInfoDouble(ACCOUNT_EQUITY));
   }

   double RecomputeOpenRiskPercent(PositionSizer &sizer,const ulong magic)
   {
      double capital = m_dailyGuard.DayAnchorEquity();
      if(capital<=0.0)
         capital = AccountInfoDouble(ACCOUNT_EQUITY);
      if(capital<=0.0)
         capital = AccountInfoDouble(ACCOUNT_BALANCE);
      if(capital<=0.0)
         return 0.0;

      double point = SymbolInfoDouble(_Symbol,SYMBOL_POINT);
      if(point<=0.0)
         point = _Point;
      double perPoint = sizer.PipValuePerLot();

      double totalRiskAmt = 0.0;
      for(int i=PositionsTotal()-1; i>=0; --i)
      {
         ulong ticket = PositionGetTicket(i);
         if(!PositionSelectByTicket(ticket))
            continue;
         if(PositionGetString(POSITION_SYMBOL)!=_Symbol)
            continue;
         if((ulong)PositionGetInteger(POSITION_MAGIC)!=magic)
            continue;

         double vol = PositionGetDouble(POSITION_VOLUME);
         double sl  = PositionGetDouble(POSITION_SL);
         if(vol<=0.0 || sl<=0.0)
            continue;

         double price = PositionGetDouble(POSITION_PRICE_CURRENT);
         double ptsToSL = MathAbs(price-sl)/MathMax(point,1e-9);
         totalRiskAmt += ptsToSL*perPoint*vol;
      }
      return (capital>0.0 ? 100.0*(totalRiskAmt/capital) : 0.0);
   }

   bool HasSufficientMargin(const int direction,const double volume,const double price) const
   {
      if(volume<=0.0)
         return false;

      ENUM_ORDER_TYPE type = (direction>0 ? ORDER_TYPE_BUY : ORDER_TYPE_SELL);
      double margin = 0.0;
      if(!OrderCalcMargin(type,_Symbol,volume,price,margin) || margin<=0.0)
      {
         if(m_debugMode || m_verboseMode)
            Print("MARGIN DEBUG: OrderCalcMargin failed or margin<=0");
         return (m_debugMode ? true : false);
      }

      double freeMargin = AccountInfoDouble(ACCOUNT_MARGIN_FREE);
      double minRatio = 1.1;
      bool ok = (freeMargin > margin * minRatio);
      if(m_debugMode || m_verboseMode)
      {
         double ratio = (margin>0.0 ? freeMargin/margin : 0.0);
         PrintFormat("MARGIN DEBUG: freeMargin=%.2f required=%.2f ratio=%.2f minRatio=%.2f ok=%s",
                     freeMargin,margin,ratio,minRatio,ok?"true":"false");
         if(!ok)
         {
            if(m_debugMode)
               Print("MARGIN DEBUG: insufficient margin but proceeding due to debug mode");
            else
               Print("MARGIN DEBUG: insufficient margin -> entry blocked");
         }
      }
      if(!ok)
         return m_debugMode;
      return true;
   }

   void RefreshOpenRisk(PositionSizer &sizer,const ulong magic)
   {
      double pct = RecomputeOpenRiskPercent(sizer,magic);
      m_dailyGuard.SetOpenRiskPercent(pct);
   }

   bool EquityKillSwitchTriggered()
   {
      if(m_maxEquityDDPercent<=0.0)
         return false;
      double equity = AccountInfoDouble(ACCOUNT_EQUITY);
      if(m_useStaticOverallDD)
      {
         if(m_initialEquity<=0.0)
            return false;
         double ddStatic = 100.0*(m_initialEquity-equity)/MathMax(1.0,m_initialEquity);
         if(ddStatic >= m_maxEquityDDPercent)
         {
            m_killSwitchLatched = true;
            return true;
         }
         return false;
      }
      if(equity>m_equityPeak)
         m_equityPeak = equity;
      if(m_equityPeak<=0.0)
         return false;
      double ddPercent = (m_equityPeak-equity)/MathMax(1.0,m_equityPeak)*100.0;
      if(ddPercent >= m_maxEquityDDPercent)
      {
         m_killSwitchLatched = true;
         return true;
      }
      return false;
   }

   void SetDynamicRiskEnabled(const bool enabled)
   {
      m_useDynamicRisk = enabled;
   }

   void SetDebugMode(const bool debug)
   {
      m_debugMode = debug;
      m_dailyGuard.SetDebugMode(debug);
   }

   void SetVerboseMode(const bool verbose)
   {
      // Ergänzt reine Diagnose-Logs, ohne die Risk-Guards (anders als Debug) zu überstimmen.
      m_verboseMode = verbose;
      m_dailyGuard.SetVerboseMode(verbose);
   }

   bool KillSwitchLatched() const
   {
      return m_killSwitchLatched;
   }

   bool AllowNewTrade(const double stopPoints,PositionSizer &sizer,RegimeFilter &regime,double &volume,double &riskPercent,const double manualRiskScale=1.0)
   {
      if(m_killSwitchLatched)
      {
         if(m_verboseMode)
            Print("RISK DEBUG: kill switch active -> entry blocked");
         return false;
      }

      if(manualRiskScale<=0.0)
      {
         if(m_verboseMode)
            Print("RISK DEBUG: manual risk scale <= 0 -> entry blocked");
         return false;
      }

      if(!m_dailyGuard.CanOpenNewTrade())
      {
         if(m_verboseMode)
            Print("RISK DEBUG: trade limit reached -> entry blocked");
         if(m_debugMode)
            Print("RISK DEBUG: overriding trade limit due to debug mode");
         else
            return false;
      }

      double balance = AccountInfoDouble(ACCOUNT_BALANCE);
      double riskAdjust = m_dailyGuard.RiskReductionFactor();
      double effectiveSetting = m_riskSetting;
      if(m_debugMode || m_verboseMode)
      {
         PrintFormat("RISK DEBUG: stopPoints=%.1f balance=%.2f riskSetting=%.2f riskAdjust=%.2f manualScale=%.2f mode=%d",
                     stopPoints,balance,m_riskSetting,riskAdjust,manualRiskScale,(int)m_riskMode);
      }
      if(m_useDynamicRisk)
      {
         RegimeBucket bucket = regime.CurrentBucket();
         double factor = m_normalFactor;
         if(bucket==REGIME_HIGH)
            factor = m_highFactor;
         else if(bucket==REGIME_LOW)
            factor = m_lowFactor;
         effectiveSetting *= factor;
      }
      double combinedAdjust = riskAdjust * manualRiskScale;
      double lot = sizer.CalculateVolume(m_riskMode,effectiveSetting,stopPoints,balance,combinedAdjust);
      SymbolContext ctx = sizer.Context();
      if(m_debugMode || m_verboseMode)
      {
         PrintFormat("RISK DEBUG: rawLot=%.4f minLot=%.4f maxLot=%.4f",
                     lot,ctx.minLot,ctx.maxLot);
      }
      if(lot<ctx.minLot)
      {
         if(m_debugMode)
         {
            PrintFormat("RISK DEBUG: lot %.4f < minLot %.4f -> clamping to minLot due to debug",lot,ctx.minLot);
            lot = ctx.minLot;
         }
         else
         {
            if(m_verboseMode)
               PrintFormat("RISK DEBUG: lot %.4f < minLot %.4f -> reject",lot,ctx.minLot);
            return false;
         }
      }
      if(lot>ctx.maxLot)
      {
         if(m_debugMode)
         {
            PrintFormat("RISK DEBUG: lot %.4f > maxLot %.4f -> clamping to maxLot due to debug",lot,ctx.maxLot);
            lot = ctx.maxLot;
         }
         else
         {
            if(m_verboseMode)
               PrintFormat("RISK DEBUG: lot %.4f > maxLot %.4f -> clamped",lot,ctx.maxLot);
            lot = ctx.maxLot;
         }
      }

      if(m_riskMode==RISK_FIXED_LOTS)
      {
         double perLotLoss = stopPoints * sizer.PipValuePerLot();
         riskPercent = (lot * perLotLoss)/balance*100.0;
      }
      else
      {
         riskPercent = effectiveSetting*combinedAdjust;
      }

      if(m_debugMode || m_verboseMode)
      {
         PrintFormat("RISK DEBUG: riskPercent=%.2f%% (combinedAdjust=%.2f)",riskPercent,combinedAdjust);
      }

      double riskWcPercent = riskPercent;
      if(stopPoints>0.0 && m_slippageBudgetPts>0.0)
         riskWcPercent = riskPercent*(1.0 + (m_slippageBudgetPts/stopPoints));
      double equityNow = AccountInfoDouble(ACCOUNT_EQUITY);
      if(m_debugMode || m_verboseMode)
      {
         PrintFormat("RISK DEBUG: riskWcPercent=%.2f%% equity=%.2f dayLoss=%.2f%% realized=%.2f%% open=%.2f%% limit=%.2f%%",
                     riskWcPercent,
                     equityNow,
                     m_dailyGuard.EquityLossPercent(equityNow),
                     m_dailyGuard.RealizedLossPercent(),
                     m_dailyGuard.OpenRiskPercent(),
                     m_dailyGuard.MaxDailyRiskPercent());
      }
      bool allowed = m_dailyGuard.AllowNewTrade(riskWcPercent,equityNow);
      if(!allowed)
      {
         if(m_debugMode)
         {
            Print("RISK DEBUG: DailyGuard rejected trade -> overriding due to debug mode");
         }
         else
         {
            if(m_verboseMode)
               Print("RISK DEBUG: DailyGuard rejected trade -> entry blocked");
            return false;
         }
      }

      volume = lot;
      if(m_debugMode || m_verboseMode)
      {
         PrintFormat("RISK DEBUG: finalVolume=%.4f",volume);
      }
      return true;
   }

   bool DailyLimitBreached()
   {
      return m_dailyGuard.ShouldFlatten(AccountInfoDouble(ACCOUNT_EQUITY));
   }

   void OnTradeOpened(const double riskPercent)
   {
      if(riskPercent>0.0)
         m_dailyGuard.RegisterOpenRisk(riskPercent);
      m_dailyGuard.RegisterNewTrade();
   }

   void OnTradeClosed(const double profit,const double riskPercent)
   {
      if(riskPercent>0.0)
         m_dailyGuard.RemoveOpenRisk(riskPercent);
      m_dailyGuard.RegisterResult(profit,AccountInfoDouble(ACCOUNT_BALANCE));
   }

   void ConfigureTradeDiscipline(const int maxNewTrades,const int maxLosingTrades,const int maxLosingStreak,const double riskScaleAfterStreak)
   {
      m_dailyGuard.ConfigureTradeDiscipline(maxNewTrades,maxLosingTrades,maxLosingStreak,riskScaleAfterStreak);
   }

   bool CanOpenNewTrade() const
   {
      return m_dailyGuard.CanOpenNewTrade();
   }

   RiskMode Mode() { return m_riskMode; }
   double RiskSetting() { return m_riskSetting; }
};

#endif // __RISK_ENGINE_MQH__
// --- END inlined module: modules/RiskEngine.mqh ---

// --- BEGIN inlined module: modules/ExitEngine.mqh ---
#ifndef __EXIT_ENGINE_MQH__
#define __EXIT_ENGINE_MQH__

#include "EntryEngine.mqh"
#include "RegimeFilter.mqh"
#include "BrokerUtils.mqh"
#include "Sizer.mqh"

enum StopSourceTag
{
   STOP_SOURCE_INITIAL = 0,
   STOP_SOURCE_ADAPTIVE,
   STOP_SOURCE_BREAK_EVEN,
   STOP_SOURCE_TRAIL,
   STOP_SOURCE_TIME
};

enum ExitReasonTag
{
   EXIT_REASON_UNKNOWN = 0,
   EXIT_REASON_INITIAL_SL,
   EXIT_REASON_ADAPTIVE_SL,
   EXIT_REASON_BREAK_EVEN,
   EXIT_REASON_TRAIL,
   EXIT_REASON_TIME,
   EXIT_REASON_HARD_TP
};

struct TradeMetadata
{
   ulong         ticket;
   int           direction;
   double        entryPrice;
   double        initialStop;
   double        rPoints;
   bool          breakEvenDone;
   bool          partialDone;
   bool          timeStopTightened;
   datetime      openTime;
   EntryFamily   family;
   RegimeBucket  regime;
   SessionWindow session;
   double        riskPercent;
   double        highestPrice;
   double        lowestPrice;
   double        finalTpPrice;
   bool          useHardFinalTp;
   double        quality;
   BiasStrength  biasStrength;
   string        biasLabel;
   bool          adaptiveApplied;
   double        entryAtr;
   double        maxFavorableR;
   double        maxAdverseR;
   double        lastKnownSL;
   double        lastKnownTP;
   int           lastBarsInTrade;
   bool          fallbackTrade;
   StopSourceTag lastStopSource;
};

class ExitEngine
{
private:
   TradeMetadata m_positions[16];
   int           m_count;
   double        m_partialFraction;
   double        m_breakEvenR;
   double        m_partialTP_R;
   double        m_finalTP_R;
   double        m_trailStart_R;
   double        m_trailDistance_R;
   bool          m_useHardFinalTP;
   bool          m_useTimeStop;
   int           m_maxBarsInTrade;
   double        m_timeStopProtectR;
   bool          m_useAdaptiveSL;
   int           m_adaptiveAfterBars;
   double        m_adaptiveMultiplier;
   double        m_adaptiveMinProfitR;
   ENUM_TIMEFRAMES m_entryTimeframe;
   bool          m_verbose;
   bool          m_enableTelemetry;
   string        m_logFolder;
   string        m_entryFileName;
   string        m_summaryFileName;
   bool          m_entryHeaderWritten;
   bool          m_summaryHeaderWritten;

   struct TelemetryConfigKV
   {
      string key;
      string value;
   };

   TelemetryConfigKV m_configSnapshot[16];
   int               m_configSnapshotCount;
   string            m_qualityLabel;
   string            m_trendLabel;
   bool              m_entryConfigWritten;
   bool              m_summaryConfigWritten;

   void RemoveAt(const int index)
   {
      if(index<0 || index>=m_count)
         return;
      for(int i=index;i<m_count-1;i++)
         m_positions[i] = m_positions[i+1];
      m_count = MathMax(0,m_count-1);
   }

   void EnsureTelemetryFolder()
   {
      if(!m_enableTelemetry)
         return;
      string folder = (m_logFolder=="" ? "XAU_Swing_TrendEA_Pro" : m_logFolder);
      FolderCreate(folder,FILE_COMMON);
      m_logFolder = folder;
   }

   string ComposePath(const string fileName) const
   {
      if(m_logFolder=="")
         return fileName;
      return m_logFolder + "/" + fileName;
   }

   void WriteConfigHeader(const int handle,bool &writtenFlag)
   {
      if(writtenFlag)
         return;
      if(handle==INVALID_HANDLE)
      {
         writtenFlag = true;
         return;
      }
      if(m_qualityLabel!="")
         FileWrite(handle,"#quality_mode",m_qualityLabel);
      if(m_trendLabel!="")
         FileWrite(handle,"#trend_filter",m_trendLabel);
      for(int i=0;i<m_configSnapshotCount;i++)
         FileWrite(handle,"#input",m_configSnapshot[i].key,m_configSnapshot[i].value);
      writtenFlag = true;
   }

   void LogRegistration(const TradeMetadata &meta,const double volume)
   {
      if(!m_enableTelemetry)
         return;
      EnsureTelemetryFolder();
      string fileName = (m_entryFileName=="" ? "trade_log.csv" : m_entryFileName);
      int handle = FileOpen(ComposePath(fileName),FILE_WRITE|FILE_READ|FILE_CSV|FILE_COMMON,';');
      if(handle!=INVALID_HANDLE)
      {
         FileSeek(handle,0,SEEK_END);
         ulong pos = FileTell(handle);
         if(pos==0)
            WriteConfigHeader(handle,m_entryConfigWritten);
         else
            m_entryConfigWritten = true;
         if(pos==0 && !m_entryHeaderWritten)
         {
            FileWrite(handle,
                      "entry_time",
                      "ticket",
                      "volume",
                      "direction",
                      "family",
                      "regime",
                      "session",
                      "risk_points",
                      "initial_stop",
                      "final_tp",
                      "quality",
                      "bias_strength",
                      "risk_percent",
                      "fallback_mode");
            m_entryHeaderWritten = true;
         }
         else if(pos>0)
            m_entryHeaderWritten = true;
         FileWrite(handle,
                   TimeToString(TimeCurrent(),TIME_DATE|TIME_SECONDS),
                   meta.ticket,
                   volume,
                   meta.direction,
                   meta.family,
                   meta.regime,
                   meta.session,
                   meta.rPoints,
                   meta.initialStop,
                   meta.finalTpPrice,
                   meta.quality,
                   meta.biasStrength,
                   meta.riskPercent,
                   meta.fallbackTrade?"true":"false");
         FileClose(handle);
      }
   }

   void LogSummary(const TradeMetadata &meta,const datetime exitTime,const double exitPrice,const double profit,
                   const double finalR,const double commission,const double swap,const string &exitLabel)
   {
      if(!m_enableTelemetry)
         return;
      EnsureTelemetryFolder();
      string fileName = (m_summaryFileName=="" ? "trade_telemetry.csv" : m_summaryFileName);
      int handle = FileOpen(ComposePath(fileName),FILE_WRITE|FILE_READ|FILE_CSV|FILE_COMMON,';');
      if(handle==INVALID_HANDLE)
         return;
      FileSeek(handle,0,SEEK_END);
      ulong pos = FileTell(handle);
      if(pos==0)
         WriteConfigHeader(handle,m_summaryConfigWritten);
      else
         m_summaryConfigWritten = true;
      if(pos==0 && !m_summaryHeaderWritten)
      {
         FileWrite(handle,
                   "entry_time",
                   "exit_time",
                   "ticket",
                   "direction",
                   "setup_type",
                   "risk_percent",
                   "r_exit",
                   "mfe_r",
                   "mae_r",
                   "bars_in_trade",
                   "exit_type",
                   "session",
                   "regime",
                   "quality",
                   "bias_strength",
                   "bias_label",
                   "profit",
                   "commission",
                   "swap",
                   "fallback_mode",
                   "entry_price",
                   "exit_price",
                   "initial_sl",
                   "final_tp",
                   "entry_weekday",
                   "entry_hour");
         m_summaryHeaderWritten = true;
      }
      else if(pos>0)
         m_summaryHeaderWritten = true;
      string typeLabel = (meta.family==ENTRY_FAMILY_PULLBACK ? "PULLBACK" : "BREAKOUT");
      if(meta.fallbackTrade)
         typeLabel += "_FALLBACK";
      MqlDateTime entryDt;
      TimeToStruct(meta.openTime,entryDt);
      string weekday = IntegerToString(entryDt.day_of_week);
      switch(entryDt.day_of_week)
      {
         case 1: weekday = "Monday"; break;
         case 2: weekday = "Tuesday"; break;
         case 3: weekday = "Wednesday"; break;
         case 4: weekday = "Thursday"; break;
         case 5: weekday = "Friday"; break;
         default: weekday = IntegerToString(entryDt.day_of_week); break;
      }
      FileWrite(handle,
                TimeToString(meta.openTime,TIME_DATE|TIME_SECONDS),
                TimeToString(exitTime,TIME_DATE|TIME_SECONDS),
                meta.ticket,
                meta.direction,
                typeLabel,
                meta.riskPercent,
                finalR,
                meta.maxFavorableR,
                meta.maxAdverseR,
                meta.lastBarsInTrade,
                exitLabel,
                meta.session,
                meta.regime,
                meta.quality,
                meta.biasStrength,
                meta.biasLabel,
                profit,
                commission,
                swap,
                meta.fallbackTrade?"true":"false",
                meta.entryPrice,
                exitPrice,
                meta.initialStop,
                meta.finalTpPrice,
                weekday,
                entryDt.hour);
      FileClose(handle);
   }

   double PointsToPrice(const double points,const double pointSize) const
   {
      return points * pointSize;
   }

public:
   ExitEngine(): m_count(0), m_partialFraction(0.5), m_breakEvenR(1.0), m_partialTP_R(1.2), m_finalTP_R(2.5),
                 m_trailStart_R(1.5), m_trailDistance_R(1.0), m_useHardFinalTP(true), m_useTimeStop(true),
                 m_maxBarsInTrade(30), m_timeStopProtectR(0.5),
                 m_useAdaptiveSL(true), m_adaptiveAfterBars(10), m_adaptiveMultiplier(1.2), m_adaptiveMinProfitR(0.5),
                 m_entryTimeframe(PERIOD_H1), m_verbose(false),
                 m_enableTelemetry(false), m_logFolder("XAU_Swing_TrendEA_Pro"),
                 m_entryFileName("trade_log.csv"), m_summaryFileName("trade_telemetry.csv"),
                 m_entryHeaderWritten(false), m_summaryHeaderWritten(false),
                 m_configSnapshotCount(0), m_qualityLabel(""), m_trendLabel(""),
                 m_entryConfigWritten(false), m_summaryConfigWritten(false)
   {
   }

   void ConfigureRManagement(const double partialFraction,const double breakEvenR,const double partialTP_R,
                             const double finalTP_R,const double trailStart_R,const double trailDistance_R,
                             const bool useHardFinalTP,const bool useTimeStop,const int maxBarsInTrade,
                             const double timeStopProtectR)
   {
      // All exit decisions operate in R-multiples so partials/trails/time stops scale with the
      // initial stop distance regardless of volatility regime.
      m_partialFraction = MathMax(0.0,MathMin(1.0,partialFraction));
      m_breakEvenR = MathMax(0.0,breakEvenR);
      m_partialTP_R = MathMax(0.0,partialTP_R);
      m_finalTP_R = MathMax(0.0,finalTP_R);
      m_trailStart_R = MathMax(0.0,trailStart_R);
      m_trailDistance_R = MathMax(0.0,trailDistance_R);
      m_useHardFinalTP = useHardFinalTP;
      m_useTimeStop = useTimeStop;
      m_maxBarsInTrade = MathMax(1,maxBarsInTrade);
      m_timeStopProtectR = timeStopProtectR;
   }

   void SetEntryTimeframe(const ENUM_TIMEFRAMES tf)
   {
      m_entryTimeframe = tf;
   }

   void SetVerbose(const bool verbose)
   {
      m_verbose = verbose;
   }

   void ConfigureAdaptiveSL(const bool useAdaptive,const int afterBars,const double atrMultiplier,const double minProfitR)
   {
      m_useAdaptiveSL = useAdaptive;
      m_adaptiveAfterBars = MathMax(1,afterBars);
      m_adaptiveMultiplier = MathMax(0.0,atrMultiplier);
      m_adaptiveMinProfitR = minProfitR;
   }

   void ConfigureTelemetry(const bool enable,const string folder="",const string prefix="")
   {
      m_enableTelemetry = enable;
      if(folder!="")
         m_logFolder = folder;
      string base = (prefix=="" ? "trade" : prefix);
      if(base=="trade")
      {
         m_entryFileName = "trade_log.csv";
         m_summaryFileName = "trade_telemetry.csv";
      }
      else
      {
         m_entryFileName = base + "_entries.csv";
         m_summaryFileName = base + "_telemetry.csv";
      }
      m_entryHeaderWritten = false;
      m_summaryHeaderWritten = false;
      m_entryConfigWritten = false;
      m_summaryConfigWritten = false;
   }

   void SetTelemetryConfigSnapshot(const string qualityLabel,const string trendLabel,
                                   string &inputNames[],string &inputValues[],const int count)
   {
      m_qualityLabel = qualityLabel;
      m_trendLabel = trendLabel;
      int capacity = ArraySize(m_configSnapshot);
      int copyCount = (count<capacity ? count : capacity);
      m_configSnapshotCount = copyCount;
      for(int i=0;i<copyCount;i++)
      {
         m_configSnapshot[i].key = inputNames[i];
         m_configSnapshot[i].value = inputValues[i];
      }
      for(int i=copyCount;i<capacity;i++)
      {
         m_configSnapshot[i].key = "";
         m_configSnapshot[i].value = "";
      }
      m_entryConfigWritten = false;
      m_summaryConfigWritten = false;
   }

   void Register(const ulong ticket,const EntrySignal &signal,const double rPoints,const double volume,const double riskPercent,
                 const string &biasLabel)
   {
      if(m_count>=ArraySize(m_positions))
         return;

      TradeMetadata meta;
      meta.ticket = ticket;
      meta.direction = signal.direction;
      meta.entryPrice = signal.entryPrice;
      meta.initialStop = signal.stopLoss;
      meta.rPoints = rPoints;
      meta.breakEvenDone = false;
      meta.partialDone = false;
      meta.timeStopTightened = false;
      meta.openTime = TimeCurrent();
      meta.family = signal.family;
      meta.regime = signal.regime;
      meta.session = signal.session;
      meta.riskPercent = riskPercent;
      meta.highestPrice = signal.entryPrice;
      meta.lowestPrice  = signal.entryPrice;
      meta.useHardFinalTp = m_useHardFinalTP;
      meta.quality = signal.quality;
      meta.biasStrength = signal.biasStrength;
      meta.biasLabel = biasLabel;
      meta.finalTpPrice = (m_useHardFinalTP ? signal.entryPrice + signal.direction*m_finalTP_R*rPoints*_Point : 0.0);
      meta.adaptiveApplied = !m_useAdaptiveSL;
      meta.entryAtr = MathAbs(signal.atr);
      meta.maxFavorableR = 0.0;
      meta.maxAdverseR = 0.0;
      meta.lastKnownSL = signal.stopLoss;
      meta.lastKnownTP = meta.finalTpPrice;
      meta.lastBarsInTrade = 0;
      meta.fallbackTrade = signal.fallbackRelaxed;
      meta.lastStopSource = STOP_SOURCE_INITIAL;

      m_positions[m_count++] = meta;

      if(m_verbose)
      {
         PrintFormat("EXIT DEBUG: register ticket=%I64u dir=%d entry=%.2f rPoints=%.1f",ticket,meta.direction,meta.entryPrice,meta.rPoints);
      }
      LogRegistration(meta,volume);
   }

   ExitReasonTag DeriveExitReason(const TradeMetadata &meta,const double exitPrice,const double point) const
   {
      double tolerance = MathMax(point*2.0,point*0.5);
      if(meta.useHardFinalTp && meta.finalTpPrice>0.0 && MathAbs(exitPrice-meta.finalTpPrice)<=tolerance)
         return EXIT_REASON_HARD_TP;
      if(meta.lastKnownSL>0.0 && MathAbs(exitPrice-meta.lastKnownSL)<=tolerance)
      {
         switch(meta.lastStopSource)
         {
            case STOP_SOURCE_BREAK_EVEN: return EXIT_REASON_BREAK_EVEN;
            case STOP_SOURCE_TRAIL:      return EXIT_REASON_TRAIL;
            case STOP_SOURCE_TIME:       return EXIT_REASON_TIME;
            case STOP_SOURCE_ADAPTIVE:   return EXIT_REASON_ADAPTIVE_SL;
            default:                     return EXIT_REASON_INITIAL_SL;
         }
      }
      if(MathAbs(exitPrice-meta.initialStop)<=tolerance)
         return EXIT_REASON_INITIAL_SL;
      return EXIT_REASON_UNKNOWN;
   }

   string ExitReasonToString(const ExitReasonTag reason) const
   {
      switch(reason)
      {
         case EXIT_REASON_INITIAL_SL:   return "STOP_LOSS";
         case EXIT_REASON_ADAPTIVE_SL:  return "ADAPTIVE_SL";
         case EXIT_REASON_BREAK_EVEN:   return "BREAK_EVEN";
         case EXIT_REASON_TRAIL:        return "TRAIL";
         case EXIT_REASON_TIME:         return "TIME_STOP";
         case EXIT_REASON_HARD_TP:      return "HARD_TP";
         default:                       return "UNKNOWN";
      }
   }

   double OnPositionClosed(const ulong ticket,const double exitPrice,const datetime exitTime,const double profit,
                           const double commission,const double swap)
   {
      double risk = 0.0;
      for(int i=0;i<m_count;i++)
      {
         if(m_positions[i].ticket==ticket)
         {
            risk = m_positions[i].riskPercent;
            double point = SymbolInfoDouble(_Symbol,SYMBOL_POINT);
            if(point<=0.0)
               point = _Point;
            double finalR = 0.0;
            if(point>0.0 && m_positions[i].rPoints>0.0)
               finalR = (exitPrice - m_positions[i].entryPrice)*m_positions[i].direction/(m_positions[i].rPoints*point);
            ExitReasonTag reason = DeriveExitReason(m_positions[i],exitPrice,point);
            string reasonLabel = ExitReasonToString(reason);
            LogSummary(m_positions[i],exitTime,exitPrice,profit,finalR,commission,swap,reasonLabel);
            RemoveAt(i);
            break;
         }
      }
      return risk;
   }

   void Manage(BrokerUtils &broker,PositionSizer &sizer,RegimeFilter &regime)
   {
      double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
      double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);
      SymbolContext ctx = sizer.Context();
      double point = (ctx.point>0.0 ? ctx.point : _Point);
      double minStep = 10.0*point;
      int periodSeconds = PeriodSeconds(m_entryTimeframe);
      if(periodSeconds<=0)
         periodSeconds = 3600;

      for(int i=m_count-1;i>=0;i--)
      {
         if(!PositionSelectByTicket(m_positions[i].ticket))
            continue;

         double currentPrice = (m_positions[i].direction>0 ? bid : ask);
         if(m_positions[i].direction>0)
            m_positions[i].highestPrice = MathMax(m_positions[i].highestPrice,currentPrice);
         else
            m_positions[i].lowestPrice = MathMin(m_positions[i].lowestPrice,currentPrice);

         if(m_positions[i].rPoints<=0.0)
            continue;

         double rToPrice = PointsToPrice(m_positions[i].rPoints,point);
         if(rToPrice<=0.0)
            continue;

         double currentR = (currentPrice - m_positions[i].entryPrice)*m_positions[i].direction/(rToPrice);

         double currentSL = PositionGetDouble(POSITION_SL);
         double currentTP = PositionGetDouble(POSITION_TP);

         m_positions[i].maxFavorableR = MathMax(m_positions[i].maxFavorableR,currentR);
         m_positions[i].maxAdverseR = MathMin(m_positions[i].maxAdverseR,currentR);
         m_positions[i].lastKnownSL = currentSL;
         m_positions[i].lastKnownTP = currentTP;

         double elapsedSeconds = (double)(TimeCurrent() - m_positions[i].openTime);
         int barsInTrade = (int)MathFloor(elapsedSeconds/periodSeconds);
         if(barsInTrade<0)
            barsInTrade = 0;
         m_positions[i].lastBarsInTrade = barsInTrade;

         if(m_useAdaptiveSL && !m_positions[i].adaptiveApplied && m_adaptiveAfterBars>0 && barsInTrade >= m_adaptiveAfterBars)
         {
            if(currentR >= m_adaptiveMinProfitR)
            {
               m_positions[i].adaptiveApplied = true;
            }
            else
            {
               double atrBasis = (m_positions[i].entryAtr>0.0 ? m_positions[i].entryAtr : regime.AtrH1());
               double adaptiveDist = atrBasis * m_adaptiveMultiplier;
               if(adaptiveDist<=0.0)
               {
                  m_positions[i].adaptiveApplied = true;
               }
               else
               {
                  double adaptivePrice = m_positions[i].entryPrice - m_positions[i].direction*adaptiveDist;
                  bool canImprove = (m_positions[i].direction>0 ? adaptivePrice > currentSL + minStep : adaptivePrice < currentSL - minStep);
                  if(canImprove)
                  {
                     if(m_positions[i].direction>0)
                        adaptivePrice = MathMin(adaptivePrice,currentPrice - minStep);
                     else
                        adaptivePrice = MathMax(adaptivePrice,currentPrice + minStep);
                     if(broker.ModifySL(m_positions[i].ticket,adaptivePrice))
                     {
                        m_positions[i].adaptiveApplied = true;
                        m_positions[i].lastStopSource = STOP_SOURCE_ADAPTIVE;
                        m_positions[i].lastKnownSL = adaptivePrice;
                        currentSL = adaptivePrice;
                        if(m_verbose)
                           PrintFormat("EXIT DEBUG: adaptive SL tightened ticket=%I64u newSL=%.2f",m_positions[i].ticket,adaptivePrice);
                     }
                  }
                  else
                  {
                     m_positions[i].adaptiveApplied = true;
                  }
               }
            }
         }

         // Break-even management
         if(!m_positions[i].breakEvenDone && m_breakEvenR>0.0 && currentR >= m_breakEvenR)
         {
            double breakEvenPrice = m_positions[i].entryPrice;
            if((m_positions[i].direction>0 && breakEvenPrice>currentSL+minStep) || (m_positions[i].direction<0 && breakEvenPrice<currentSL-minStep))
            {
               if(broker.ModifySL(m_positions[i].ticket,breakEvenPrice))
               {
                  m_positions[i].breakEvenDone = true;
                  m_positions[i].lastStopSource = STOP_SOURCE_BREAK_EVEN;
                  m_positions[i].lastKnownSL = breakEvenPrice;
                  if(m_verbose)
                     PrintFormat("EXIT DEBUG: break-even set ticket=%I64u sl=%.2f",m_positions[i].ticket,breakEvenPrice);
               }
            }
         }

         // Partial close
         if(!m_positions[i].partialDone && m_partialFraction>0.0 && m_partialFraction<1.0 && m_partialTP_R>0.0 && currentR >= m_partialTP_R)
         {
            double volume = PositionGetDouble(POSITION_VOLUME);
            double partialVolume = sizer.NormalizeVolume(volume*m_partialFraction);
            if(partialVolume>0.0 && partialVolume<volume)
            {
               if(broker.ClosePartial(m_positions[i].ticket,partialVolume))
               {
                  m_positions[i].partialDone = true;
                  if(!m_positions[i].breakEvenDone)
                  {
                     double breakEvenPrice = m_positions[i].entryPrice;
                     if(broker.ModifySL(m_positions[i].ticket,breakEvenPrice))
                     {
                        m_positions[i].breakEvenDone = true;
                        m_positions[i].lastStopSource = STOP_SOURCE_BREAK_EVEN;
                        m_positions[i].lastKnownSL = breakEvenPrice;
                     }
                  }
                  if(m_verbose)
                     PrintFormat("EXIT DEBUG: partial closed ticket=%I64u volume=%.2f",m_positions[i].ticket,partialVolume);
               }
            }
         }

         // Trailing stop (only if no hard TP)
         if(!m_positions[i].useHardFinalTp && m_trailStart_R>0.0 && m_trailDistance_R>0.0 && currentR >= m_trailStart_R)
         {
            double extreme = (m_positions[i].direction>0 ? m_positions[i].highestPrice : m_positions[i].lowestPrice);
            double trailPrice = extreme - m_positions[i].direction*m_trailDistance_R*rToPrice;
            bool improved = false;
            if(m_positions[i].direction>0)
               improved = (trailPrice > currentSL + minStep);
            else
               improved = (trailPrice < currentSL - minStep);
            if(improved)
            {
               if(m_positions[i].direction>0)
                  trailPrice = MathMin(trailPrice,currentPrice - minStep);
               else
                  trailPrice = MathMax(trailPrice,currentPrice + minStep);
               if(broker.ModifySL(m_positions[i].ticket,trailPrice))
               {
                  m_positions[i].lastStopSource = STOP_SOURCE_TRAIL;
                  m_positions[i].lastKnownSL = trailPrice;
                  if(m_verbose)
                     PrintFormat("EXIT DEBUG: trailing stop adjusted ticket=%I64u newSL=%.2f",m_positions[i].ticket,trailPrice);
               }
            }
         }

         // Time-based exit
         if(m_useTimeStop)
         {
            if(barsInTrade >= m_maxBarsInTrade)
            {
               if(currentR <= 0.0)
               {
                  m_positions[i].lastStopSource = STOP_SOURCE_TIME;
                  m_positions[i].lastKnownSL = currentPrice;
                  if(broker.ClosePosition(m_positions[i].ticket) && m_verbose)
                     PrintFormat("EXIT DEBUG: time stop closed ticket=%I64u at R=%.2f",m_positions[i].ticket,currentR);
                  continue;
               }
               if(!m_positions[i].timeStopTightened && m_timeStopProtectR!=0.0)
               {
                  double protective = m_positions[i].entryPrice + m_positions[i].direction*m_timeStopProtectR*rToPrice;
                  bool canImprove = (m_positions[i].direction>0 ? protective > currentSL + minStep : protective < currentSL - minStep);
                  if(canImprove)
                  {
                     if(m_positions[i].direction>0)
                        protective = MathMin(protective,currentPrice - minStep);
                     else
                        protective = MathMax(protective,currentPrice + minStep);
                     if(broker.ModifySL(m_positions[i].ticket,protective))
                     {
                        m_positions[i].timeStopTightened = true;
                        m_positions[i].lastStopSource = STOP_SOURCE_TIME;
                        m_positions[i].lastKnownSL = protective;
                        if(m_verbose)
                           PrintFormat("EXIT DEBUG: time stop tightened ticket=%I64u newSL=%.2f",m_positions[i].ticket,protective);
                     }
                  }
               }
            }
         }
      }
   }
};

#endif // __EXIT_ENGINE_MQH__
// --- END inlined module: modules/ExitEngine.mqh ---


/*
 * --------------------------------------------------------------------
 * PUBLIC PARAMETER SUMMARY (10 inputs)
 * 1. RiskPerTradePercent      – percent of equity risked per trade.
 * 2. MaxDailyLossPercent      – realised + open loss cap per day in percent.
 * 3. MaxStaticDrawdownPercent – static equity drawdown kill switch in percent
 *                               (<=0 disables the static kill switch for testing).
 * 4. AllowLongs               – enable long trades.
 * 5. AllowShorts              – enable short trades.
 * 6. SessionStartHour         – broker hour for session start (minutes fixed to 00).
 * 7. SessionEndHour           – broker hour for session end (minutes fixed to 45).
 * 8. BiasMode                 – multi-timeframe bias discipline profile.
 * 9. RRProfile                – exit / R-multiple management profile.
 *10. EnableFallbackEntries    – allow relaxed/fallback entries outside the
 *                               A-session core window.
 *
 * BiasMode:
 *  - BIAS_STRICT     enforces unanimous EMA slope alignment, raises slope/score
 *                    thresholds and disables neutral-bias trades.
 *  - BIAS_BALANCED   mirrors the legacy "Balanced v2" bias discipline with
 *                    controlled neutral exposure and selective fallbacks.
 *  - BIAS_AGGRESSIVE relaxes slope thresholds slightly and allows wider
 *                    neutral-bias participation.
 *
 * RRProfile:
 *  - RR_CONSERVATIVE uses a single 1.5R target with optional late time-stop.
 *  - RR_BALANCED     (default) applies 50-60% partials near 1.1R, BE around 0.9R
 *                    and trails from ~1.6R towards a 1.9R hard target.
 *  - RR_RUNNER       leaves a runner beyond 1R with loose trailing and no hard TP.
 */

enum ENUM_BiasMode
{
   BIAS_STRICT = 0,
   BIAS_BALANCED = 1,
   BIAS_AGGRESSIVE = 2
};

enum ENUM_RRProfile
{
   RR_CONSERVATIVE = 0,
   RR_BALANCED     = 1,
   RR_RUNNER       = 2
};

// --- Public inputs --------------------------------------------------
input double        RiskPerTradePercent      = 0.50;  // % of equity per trade
input double        MaxDailyLossPercent      = 5.00;  // realised + open loss cap per day in %
input double        MaxStaticDrawdownPercent = 12.00; // static equity DD kill switch (<=0 disables)
input bool          AllowLongs               = true;  // enable long trades
input bool          AllowShorts              = true;  // enable short trades
input int           SessionStartHour         = 7;     // broker time, minutes fixed to 00
input int           SessionEndHour           = 14;    // broker time, minutes fixed internally to 45
input ENUM_BiasMode BiasMode                 = BIAS_BALANCED;
input ENUM_RRProfile RRProfile               = RR_BALANCED;
input bool          EnableFallbackEntries    = true;  // allow relaxed fallback entries
input bool          AllowMondayTrading       = false; // disable Monday trades (largest weekly loss in tests)
input bool          AllowTuesdayTrading      = true;  // keep Tuesday active by default
input bool          AllowWednesdayTrading    = true;  // Wednesday carried most gains historically
input bool          AllowThursdayTrading     = true;  // Thursday marginal but still allowed
input bool          AllowFridayTrading       = false; // disable Friday entries (2nd worst weekday)
input bool          RestrictEntryHours       = true;  // enforce intraday hour whitelist
input int           AllowedEntryHourStart    = 9;     // inclusive start hour (broker time)
input int           AllowedEntryHourEnd      = 12;    // inclusive end hour (broker time)

// --- Internal constants ---------------------------------------------
const ulong   MAGIC_NUMBER = 20241026;
const string  TRADE_COMMENT = "XAU_Swing_TrendEA_Pro";
const bool    DEBUG_MODE = false;
const bool    FORCE_VERBOSE_LOG = false;
const bool    RANDOMIZE_ENTRY_EXIT = false;
const bool    ENABLE_CHART_ANNOTATIONS = true;
const bool    ENABLE_TRADE_TELEMETRY = true;
const int     SLIPPAGE_BUDGET_POINTS = 80;
const int     MAX_SPREAD_POINTS = 200;
const int     PROP_DAY_START_HOUR = 0;
const bool    USE_STATIC_OVERALL_DD = true;
const ENUM_TIMEFRAMES ENTRY_TIMEFRAME = PERIOD_H1;
const int     SESSION_START_MINUTE = 0;
const int     SESSION_END_MINUTE_DEFAULT = 45;
const int     SESSION_CUTOFF_MINUTE = 45;
const double  AGGRESSIVE_DISCOUNT = 0.05;
const double  AGGRESSIVE_FLOOR = 0.60;
const double  TIME_STOP_PROTECT_R_DEFAULT = 0.5;
const double  FALLBACK_SLOPE_SCALE_BASE = 0.75;
const double  FALLBACK_SCORE_DISCOUNT_BASE = 0.90;
const double  FALLBACK_RISK_SCALE_BASE = 0.70;
const string  TELEMETRY_FOLDER = "XAU_Swing_TrendEA_Pro";
const string  TELEMETRY_PREFIX_BASE = "xau_bias_rr";

// TODO: Backtest XAUUSD H1 2021-2025 (spread 20) with BIAS_BALANCED/RR_BALANCED and BIAS_STRICT/RR_CONSERVATIVE.

struct StrategyConfig
{
   int    biasVotesRequired;
   double biasSlopeThH1;
   double biasSlopeThH4;
   double biasSlopeThD1;
   double biasSlopeConfirmH1;
   double biasSlopeConfirmH4;
   double biasSlopeConfirmD1;
   double biasScoreThresholdCore;
   double biasScoreThresholdEdge;
   double biasScoreRegimeLowBoost;
   double biasScoreRegimeHighBoost;
   double coreQualityLong;
   double coreQualityShort;
   double edgeQualityLong;
   double edgeQualityShort;
   double pullbackBodyAtrMin;
   double breakoutImpulseAtrMin;
   int    breakoutRangeBars;
   bool   allowAggressiveEntries;
   bool   allowLongs;
   bool   allowShorts;
   bool   enableFallbackEntry;
   bool   enableWeekdayFallback;
   int    fallbackMinHour;
   int    fallbackMaxPer7D;
   bool   requireStrongFallback;
   bool   requireTrendForFallback;
   bool   allowFallbackWhenBiasNeutral;
   double fallbackSlopeScale;
   double fallbackScoreDiscount;
   double fallbackRiskScale;
   double neutralBiasRiskScale;
   bool   allowNeutralBiasOnEdge;
   double regimeLowQualityBoost;
   double regimeHighQualityBoost;
   double regimeLowRiskScale;
   double regimeHighRiskScale;
   bool   useDynamicRisk;
   int    maxNewTradesPerDay;
   int    maxLosingTradesPerDay;
   int    maxLosingTradesInARow;
   double riskScaleAfterLosingStreak;
   double partialTPFraction;
   double breakEvenR;
   double partialTP_R;
   double trailStart_R;
   double trailDistance_R;
   double timeStopProtectR;
   double finalTarget_R;
   int    timeStopBars;
   double initialStopATR;
   bool   useHardFinalTP;
   bool   useTimeStop;
   bool   useAdaptiveSL;
   int    adaptiveAfterBars;
   double adaptiveMultiplier;
   double adaptiveMinProfitR;
   int    lateEntryCutoffHour;
   int    lateEntryCutoffMinute;
   int    sessionEndMinute;
   int    sessionCutoffMinute;
   bool   disallowNeutralEntries;
   bool   bypassSlopeScoreCheck;
   bool   bypassSlopeVoteCheck;
   bool   requireDirectionalBias;
};

StrategyConfig MakeBalancedConfig()
{
   StrategyConfig cfg;
   cfg.biasVotesRequired = 2;
   cfg.biasSlopeThH1 = 0.020;
   cfg.biasSlopeThH4 = 0.018;
   cfg.biasSlopeThD1 = 0.015;
   cfg.biasSlopeConfirmH1 = 0.018;
   cfg.biasSlopeConfirmH4 = 0.014;
   cfg.biasSlopeConfirmD1 = 0.010;
   cfg.biasScoreThresholdCore = 0.060;
   cfg.biasScoreThresholdEdge = 0.085;
   cfg.biasScoreRegimeLowBoost = 0.015;
   cfg.biasScoreRegimeHighBoost = 0.005;
   cfg.coreQualityLong = 0.82;
   cfg.coreQualityShort = 0.76;
   cfg.edgeQualityLong = 0.90;
   cfg.edgeQualityShort = 0.85;
   cfg.pullbackBodyAtrMin = 0.45;
   cfg.breakoutImpulseAtrMin = 0.42;
   cfg.breakoutRangeBars = 6;
   cfg.allowAggressiveEntries = false;
   cfg.allowLongs = true;
   cfg.allowShorts = true;
   cfg.enableFallbackEntry = true;
   cfg.enableWeekdayFallback = true;
   cfg.fallbackMinHour = 12;
   cfg.fallbackMaxPer7D = 2;
   cfg.requireStrongFallback = true;
   cfg.requireTrendForFallback = false;
   cfg.allowFallbackWhenBiasNeutral = true;
   cfg.fallbackSlopeScale = FALLBACK_SLOPE_SCALE_BASE;
   cfg.fallbackScoreDiscount = FALLBACK_SCORE_DISCOUNT_BASE;
   cfg.fallbackRiskScale = FALLBACK_RISK_SCALE_BASE;
   cfg.neutralBiasRiskScale = 0.50;
   cfg.allowNeutralBiasOnEdge = true;
   cfg.regimeLowQualityBoost = 0.06;
   cfg.regimeHighQualityBoost = 0.03;
   cfg.regimeLowRiskScale = 0.60;
   cfg.regimeHighRiskScale = 1.05;
   cfg.useDynamicRisk = true;
   cfg.maxNewTradesPerDay = 3;
   cfg.maxLosingTradesPerDay = 3;
   cfg.maxLosingTradesInARow = 3;
   cfg.riskScaleAfterLosingStreak = 0.50;
   cfg.partialTPFraction = 0.55;
   cfg.breakEvenR = 0.85;
   cfg.partialTP_R = 1.05;
   cfg.trailStart_R = 1.45;
   cfg.trailDistance_R = 0.80;
   cfg.timeStopProtectR = TIME_STOP_PROTECT_R_DEFAULT;
   cfg.finalTarget_R = 1.75;
   cfg.timeStopBars = 36;
   cfg.initialStopATR = 1.20;
   cfg.useHardFinalTP = true;
   cfg.useTimeStop = true;
   cfg.useAdaptiveSL = true;
   cfg.adaptiveAfterBars = 10;
   cfg.adaptiveMultiplier = 1.2;
   cfg.adaptiveMinProfitR = 0.5;
   cfg.lateEntryCutoffHour = 14;
   cfg.lateEntryCutoffMinute = 0;
   cfg.sessionEndMinute = SESSION_END_MINUTE_DEFAULT;
   cfg.sessionCutoffMinute = SESSION_CUTOFF_MINUTE;
   cfg.disallowNeutralEntries = false;
   cfg.bypassSlopeScoreCheck = false;
   cfg.bypassSlopeVoteCheck = false;
   cfg.requireDirectionalBias = false;
   return cfg;
}
void ApplyBiasModeAdjustments(StrategyConfig &cfg,const ENUM_BiasMode mode,const bool fallbackEnabled)
{
   switch(mode)
   {
      case BIAS_STRICT:
         cfg.biasSlopeThH1 *= 1.25;
         cfg.biasSlopeThH4 *= 1.25;
         cfg.biasSlopeThD1 *= 1.25;
         cfg.biasSlopeConfirmH1 *= 1.25;
         cfg.biasSlopeConfirmH4 *= 1.25;
         cfg.biasSlopeConfirmD1 *= 1.25;
         cfg.biasScoreThresholdCore *= 1.20;
         cfg.biasScoreThresholdEdge *= 1.25;
         cfg.biasVotesRequired = 3;
         cfg.allowNeutralBiasOnEdge = false;
         cfg.allowFallbackWhenBiasNeutral = false;
         cfg.enableFallbackEntry = false;
         cfg.enableWeekdayFallback = false;
         cfg.requireTrendForFallback = true;
         cfg.fallbackRiskScale = 0.0;
         cfg.allowAggressiveEntries = false;
         cfg.disallowNeutralEntries = true;
         cfg.requireDirectionalBias = true;
         cfg.neutralBiasRiskScale = 0.0;
         cfg.maxLosingTradesPerDay = 2;
         cfg.maxLosingTradesInARow = 2;
         cfg.useDynamicRisk = true;
         break;
      case BIAS_AGGRESSIVE:
         cfg.biasSlopeThH1 *= 0.80;
         cfg.biasSlopeThH4 *= 0.80;
         cfg.biasSlopeThD1 *= 0.80;
         cfg.biasSlopeConfirmH1 *= 0.80;
         cfg.biasSlopeConfirmH4 *= 0.80;
         cfg.biasSlopeConfirmD1 *= 0.80;
         cfg.biasScoreThresholdCore *= 0.85;
         cfg.biasScoreThresholdEdge *= 0.80;
         cfg.allowAggressiveEntries = true;
         cfg.requireStrongFallback = false;
         cfg.allowFallbackWhenBiasNeutral = true;
         cfg.fallbackRiskScale = MathMin(1.0,FALLBACK_RISK_SCALE_BASE + 0.20);
         cfg.neutralBiasRiskScale = 0.70;
         cfg.useDynamicRisk = true;
         cfg.enableFallbackEntry = fallbackEnabled;
         cfg.enableWeekdayFallback = fallbackEnabled;
         break;
      default: // BIAS_BALANCED
         cfg.enableFallbackEntry = fallbackEnabled;
         cfg.enableWeekdayFallback = fallbackEnabled;
         cfg.allowAggressiveEntries = false;
         cfg.requireTrendForFallback = false;
         cfg.allowFallbackWhenBiasNeutral = true;
         cfg.disallowNeutralEntries = false;
         cfg.requireDirectionalBias = false;
         cfg.fallbackRiskScale = FALLBACK_RISK_SCALE_BASE;
         cfg.neutralBiasRiskScale = 0.50;
         cfg.useDynamicRisk = true;
         break;
   }

   if(mode!=BIAS_STRICT)
   {
      cfg.enableFallbackEntry = fallbackEnabled;
   }
}

void ApplyRRProfileAdjustments(StrategyConfig &cfg,const ENUM_RRProfile profile)
{
   switch(profile)
   {
      case RR_CONSERVATIVE:
         cfg.partialTPFraction = 0.0;
         cfg.breakEvenR = 0.80;
         cfg.partialTP_R = 1.50;
         cfg.trailStart_R = 0.0;
         cfg.trailDistance_R = 0.0;
         cfg.finalTarget_R = 1.50;
         cfg.timeStopBars = 60;
         cfg.useHardFinalTP = true;
         cfg.useTimeStop = true;
         cfg.timeStopProtectR = 0.40;
         cfg.useAdaptiveSL = false;
         break;
      case RR_RUNNER:
         cfg.partialTPFraction = 0.35;
         cfg.breakEvenR = 0.85;
         cfg.partialTP_R = 1.00;
         cfg.trailStart_R = 1.20;
         cfg.trailDistance_R = 1.20;
         cfg.finalTarget_R = 3.50;
         cfg.timeStopBars = 70;
         cfg.useHardFinalTP = false;
         cfg.useTimeStop = true;
         cfg.timeStopProtectR = 0.30;
         cfg.useAdaptiveSL = true;
         cfg.adaptiveAfterBars = 12;
         cfg.adaptiveMultiplier = 1.3;
         cfg.adaptiveMinProfitR = 0.6;
         break;
      default: // RR_BALANCED
         cfg.partialTPFraction = 0.55;
         cfg.breakEvenR = 0.90;
         cfg.partialTP_R = 1.10;
         cfg.trailStart_R = 1.60;
         cfg.trailDistance_R = 0.85;
         cfg.finalTarget_R = 1.90;
         cfg.timeStopBars = 40;
         cfg.useHardFinalTP = true;
         cfg.useTimeStop = true;
         cfg.timeStopProtectR = TIME_STOP_PROTECT_R_DEFAULT;
         cfg.useAdaptiveSL = true;
         cfg.adaptiveAfterBars = 10;
         cfg.adaptiveMultiplier = 1.2;
         cfg.adaptiveMinProfitR = 0.5;
         break;
   }
}

string BiasModeToString(const ENUM_BiasMode mode)
{
   switch(mode)
   {
      case BIAS_STRICT:     return "BIAS_STRICT";
      case BIAS_AGGRESSIVE: return "BIAS_AGGRESSIVE";
      default:              return "BIAS_BALANCED";
   }
}

string RRProfileToString(const ENUM_RRProfile profile)
{
   switch(profile)
   {
      case RR_CONSERVATIVE: return "RR_CONSERVATIVE";
      case RR_RUNNER:       return "RR_RUNNER";
      default:              return "RR_BALANCED";
   }
}

string ComposeTelemetryPrefix(const ENUM_BiasMode bias,const ENUM_RRProfile profile)
{
   return TELEMETRY_PREFIX_BASE + "_" + BiasModeToString(bias) + "_" + RRProfileToString(profile);
}

StrategyConfig gConfig;
string         gBiasLabel = "";
string         gRRLabel   = "";

//--- globals
BrokerUtils   gBroker;
RegimeFilter  gRegime;
SessionFilter gSession;
BiasEngine    gBias;
EntryEngine   gEntry;
PositionSizer gSizer;
RiskEngine    gRisk;
ExitEngine    gExit;

datetime      gLastBarTime = 0;
datetime      gEntryHistory[];
int           gFallbackWeekId = -1;
bool          gFallbackUsedThisWeek = false;
bool          gVerboseDecisionLog = false;
#define      RECENT_TRADE_WINDOW 10
double        gRecentTradePnL[RECENT_TRADE_WINDOW];
int           gRecentTradeCount = 0;
bool          gUseHourWhitelist = false;
int           gHourFilterStart = 0;
int           gHourFilterEnd = 0;

//--- helper declarations
bool IsNewBar();
void EvaluateNewBar();
void ManageOpenPositions();
bool HasDirectionalPosition(const int direction);
void AnnotateChart(const string message,const color col=clrDodgerBlue);
void AttemptEntry(const EntrySignal &signal);
string SessionWindowToString(const SessionWindow window,const bool fallback);
string DirectionToString(const int direction);
void CloseAllPositions();
void RecordEntryTime(const datetime entryTime,const bool fallbackTrade);
void CleanupEntryHistory(const datetime reference);
int  EntriesLastSevenDays(const datetime reference);
int  ComputeWeekId(const datetime time);
bool ShouldUseFallbackEntry(const datetime signalTime,const int recentEntries);
void ResetRecentPnL();
void RecordClosedTradePnL(const double profit);
bool RecentPnLPositive();
bool IsWeekdayAllowed(const int dayOfWeek);
bool EntryHourAllowed(const int hour);


//+------------------------------------------------------------------+
//| Expert initialization                                            |
//+------------------------------------------------------------------+
int OnInit()
{
   gConfig = MakeBalancedConfig();
   ApplyBiasModeAdjustments(gConfig,BiasMode,EnableFallbackEntries);
   ApplyRRProfileAdjustments(gConfig,RRProfile);
   gConfig.allowLongs = AllowLongs;
   gConfig.allowShorts = AllowShorts;
   if(!EnableFallbackEntries)
   {
      gConfig.enableFallbackEntry = false;
      gConfig.enableWeekdayFallback = false;
   }
   gBiasLabel = BiasModeToString(BiasMode);
   gRRLabel = RRProfileToString(RRProfile);

   gVerboseDecisionLog = (DEBUG_MODE || FORCE_VERBOSE_LOG);
   gBroker.Configure(MAGIC_NUMBER,TRADE_COMMENT,20);
   gSession.Configure(SessionStartHour,SESSION_START_MINUTE,SessionEndHour,gConfig.sessionEndMinute);
   gSession.SetDebugMode(DEBUG_MODE,false);
   gUseHourWhitelist = RestrictEntryHours;
   gHourFilterStart = MathMax(0,MathMin(23,AllowedEntryHourStart));
   gHourFilterEnd = MathMax(0,MathMin(23,AllowedEntryHourEnd));

   gEntry.Configure(RANDOMIZE_ENTRY_EXIT);
   gEntry.ConfigureSensitivity(gConfig.pullbackBodyAtrMin,gConfig.breakoutImpulseAtrMin,gConfig.breakoutRangeBars);
   gEntry.SetStopMultiplier(gConfig.initialStopATR);
   gEntry.SetQualityThresholds(gConfig.coreQualityLong,gConfig.coreQualityShort,
                               gConfig.edgeQualityLong,gConfig.edgeQualityShort,
                               gConfig.allowAggressiveEntries,AGGRESSIVE_DISCOUNT,AGGRESSIVE_FLOOR);
   gEntry.SetDirectionalPermissions(gConfig.allowLongs,gConfig.allowShorts);
   gEntry.ConfigureNeutralPolicy(gConfig.allowNeutralBiasOnEdge,gConfig.neutralBiasRiskScale);
   gEntry.ConfigureRegimeAdjustments(gConfig.regimeLowQualityBoost,gConfig.regimeHighQualityBoost,
                                     gConfig.regimeLowRiskScale,gConfig.regimeHighRiskScale);
   gEntry.SetFallbackPolicy(gConfig.requireStrongFallback,gConfig.fallbackRiskScale);

   gExit.ConfigureRManagement(gConfig.partialTPFraction,gConfig.breakEvenR,gConfig.partialTP_R,gConfig.finalTarget_R,
                              gConfig.trailStart_R,gConfig.trailDistance_R,
                              gConfig.useHardFinalTP,gConfig.useTimeStop,gConfig.timeStopBars,gConfig.timeStopProtectR);
   gExit.ConfigureAdaptiveSL(gConfig.useAdaptiveSL,gConfig.adaptiveAfterBars,gConfig.adaptiveMultiplier,gConfig.adaptiveMinProfitR);
   gExit.SetEntryTimeframe(ENTRY_TIMEFRAME);
   gExit.SetVerbose(gVerboseDecisionLog);
   string telemetryPrefix = ComposeTelemetryPrefix(BiasMode,RRProfile);
   gExit.ConfigureTelemetry(ENABLE_TRADE_TELEMETRY,TELEMETRY_FOLDER,telemetryPrefix);

   string headerNames[10];
   string headerValues[10];
   headerNames[0] = "RiskPerTradePercent";      headerValues[0] = DoubleToString(RiskPerTradePercent,2);
   headerNames[1] = "MaxDailyLossPercent";     headerValues[1] = DoubleToString(MaxDailyLossPercent,2);
   headerNames[2] = "MaxStaticDrawdownPercent";headerValues[2] = DoubleToString(MaxStaticDrawdownPercent,2);
   headerNames[3] = "AllowLongs";              headerValues[3] = (AllowLongs?"true":"false");
   headerNames[4] = "AllowShorts";             headerValues[4] = (AllowShorts?"true":"false");
   headerNames[5] = "SessionStartHour";        headerValues[5] = IntegerToString(SessionStartHour);
   headerNames[6] = "SessionEndHour";          headerValues[6] = IntegerToString(SessionEndHour);
   headerNames[7] = "BiasMode";                headerValues[7] = gBiasLabel;
   headerNames[8] = "RRProfile";               headerValues[8] = gRRLabel;
   headerNames[9] = "EnableFallbackEntries";   headerValues[9] = (EnableFallbackEntries?"true":"false");
   gExit.SetTelemetryConfigSnapshot(gBiasLabel,gRRLabel,headerNames,headerValues,10);

   string persistKey = StringFormat("STEA:%s:%I64u",_Symbol,MAGIC_NUMBER);
   double ddPercent = (MaxStaticDrawdownPercent>0.0 ? MaxStaticDrawdownPercent : 0.0);
   bool useStaticDD = (MaxStaticDrawdownPercent>0.0 && USE_STATIC_OVERALL_DD);
   // RiskEngine uses the day-anchor equity for daily caps and the recorded initial equity for
   // the static drawdown guard so that all percent checks reference a consistent capital base.
   gRisk.Configure(RISK_PERCENT_PER_TRADE,RiskPerTradePercent,MaxDailyLossPercent,ddPercent,
                   PROP_DAY_START_HOUR,persistKey,useStaticDD,(double)SLIPPAGE_BUDGET_POINTS);
   gRisk.SetDebugMode(DEBUG_MODE);
   gRisk.SetVerboseMode(gVerboseDecisionLog);
   gRisk.SetDynamicRiskEnabled(gConfig.useDynamicRisk);
   gRisk.ConfigureTradeDiscipline(gConfig.maxNewTradesPerDay,gConfig.maxLosingTradesPerDay,
                                  gConfig.maxLosingTradesInARow,gConfig.riskScaleAfterLosingStreak);

   if(!gRegime.Init(_Symbol,14))
   {
      Print("Failed to initialise regime filter");
      return INIT_FAILED;
   }
   if(!gBias.Init(_Symbol))
   {
      Print("Failed to initialise bias engine");
      return INIT_FAILED;
   }
   gBias.ConfigureThresholds(gConfig.biasVotesRequired,gConfig.biasSlopeThH1,gConfig.biasSlopeThH4,gConfig.biasSlopeThD1);
   gBias.SetSlopeThreshold(1.0);
   gBias.SetDebug(gVerboseDecisionLog);
   if(!gSizer.Init(_Symbol))
   {
      Print("Failed to initialise position sizer");
      return INIT_FAILED;
   }
   gRegime.Update(true);
   ArrayResize(gEntryHistory,0);
   gFallbackWeekId = -1;
   gFallbackUsedThisWeek = false;
   ResetRecentPnL();
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Expert deinitialisation                                          |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   gBias.Release();
   gRegime.Release();
}

bool IsNewBar()
{
   datetime currentBarTime = iTime(_Symbol,ENTRY_TIMEFRAME,0);
   if(currentBarTime<=0)
      return false;

   if(currentBarTime==gLastBarTime)
      return false;

   if(gLastBarTime>currentBarTime)
   {
      gLastBarTime = currentBarTime;
      return false;
   }

   gLastBarTime = currentBarTime;
   return true;
}

//+------------------------------------------------------------------+
//| OnTick                                                           |
//+------------------------------------------------------------------+
void OnTick()
{
   gRisk.OnNewDay();
   gRegime.Update();
   gRisk.RefreshOpenRisk(gSizer,MAGIC_NUMBER);

   if(gRisk.DailyLimitBreached())
   {
      Print("Daily equity loss limit breached -> closing all positions");
      CloseAllPositions();
      return;
   }

   if(gRisk.KillSwitchLatched())
      return;

   // MaxStaticDrawdownPercent guard: flatten and latch until the EA is restarted.
   if(gRisk.EquityKillSwitchTriggered())
   {
      PrintFormat("Equity drawdown kill switch triggered (MaxStaticDrawdownPercent=%.2f%%)",MaxStaticDrawdownPercent);
      CloseAllPositions();
      return;
   }

   ManageOpenPositions();

   if(!IsNewBar())
      return;

   EvaluateNewBar();
}

void EvaluateNewBar()
{
   datetime signalTime = gLastBarTime;
   int recentEntries = EntriesLastSevenDays(signalTime);
   int currentWeek = ComputeWeekId(signalTime);
   if(currentWeek!=gFallbackWeekId)
   {
      gFallbackWeekId = currentWeek;
      gFallbackUsedThisWeek = false;
   }
   bool useFallback = ShouldUseFallbackEntry(signalTime,recentEntries);
   double slopeScale = (useFallback ? gConfig.fallbackSlopeScale : 1.0);
   gBias.SetSlopeThreshold(slopeScale);
   if(gVerboseDecisionLog)
   {
      PrintFormat("ENTRY TRACE: new bar %s fallback=%s slopeScale=%.2f entries7d=%d",TimeToString(signalTime,TIME_DATE|TIME_MINUTES),
                  useFallback?"true":"false",slopeScale,recentEntries);
   }
   if(!gBias.Update(gRegime))
   {
      if(gVerboseDecisionLog)
         PrintFormat("ENTRY TRACE: Bias update failed at %s",TimeToString(signalTime,TIME_DATE|TIME_MINUTES));
      return;
   }

   TrendBias bias;
   gBias.ComputeTrendBias(bias,useFallback,useFallback);
   RegimeBucket regimeBucket = gRegime.CurrentBucket();
   if(gVerboseDecisionLog)
   {
      PrintFormat("BIAS TRACE: dir=%d strength=%d score=%.3f votesStrong L%d/S%d votesNear L%d/S%d slopes=%.3f/%.3f/%.3f th=%.3f/%.3f/%.3f",
                  bias.direction,(int)bias.strength,bias.score,
                  bias.votesStrongLong,bias.votesStrongShort,
                  bias.votesNearLong,bias.votesNearShort,
                  bias.slopeH1,bias.slopeH4,bias.slopeD1,
                  bias.thresholdH1,bias.thresholdH4,bias.thresholdD1);
   }

   if(gConfig.requireDirectionalBias && bias.direction==0)
   {
      if(gVerboseDecisionLog)
         Print("ENTRY TRACE: bias direction unresolved -> blocked by trend filter");
      return;
   }
   if(gConfig.disallowNeutralEntries && bias.strength==BIAS_NEUTRAL)
   {
      if(gVerboseDecisionLog)
         Print("ENTRY TRACE: neutral bias blocked by mode configuration");
      return;
   }
   if(BiasMode==BIAS_STRICT)
   {
      if(bias.direction==0)
      {
         if(gVerboseDecisionLog)
            Print("ENTRY TRACE: strict bias mode requires resolved direction");
         return;
      }
      int strictDir = (bias.direction>0 ? 1 : -1);
      if(bias.signH1!=strictDir || bias.signH4!=strictDir || bias.signD1!=strictDir)
      {
         if(gVerboseDecisionLog)
            Print("ENTRY TRACE: strict bias mode requires all slopes aligned");
         return;
      }
   }
   if(useFallback && gConfig.requireTrendForFallback && (bias.strength==BIAS_NEUTRAL || bias.direction==0))
   {
      if(gVerboseDecisionLog)
         Print("ENTRY TRACE: fallback disabled because bias is not trending");
      useFallback = false;
   }
   if(useFallback && !gConfig.allowFallbackWhenBiasNeutral && bias.strength==BIAS_NEUTRAL)
   {
      if(gVerboseDecisionLog)
         Print("ENTRY TRACE: fallback blocked for neutral bias");
      return;
   }

   SessionWindow window;
   if(!gSession.AllowsEntry(signalTime,window))
   {
      AnnotateChart("Session filter blocked entry",clrSilver);
      if(DEBUG_MODE)
         PrintFormat("ENTRY DEBUG: Session filter blocked entry at %s",TimeToString(signalTime,TIME_DATE|TIME_MINUTES));
      else if(gVerboseDecisionLog)
         PrintFormat("ENTRY TRACE: Session filter blocked entry at %s",TimeToString(signalTime,TIME_DATE|TIME_MINUTES));
      return;
   }

   MqlDateTime entryDt;
   TimeToStruct(signalTime,entryDt);
   if(!IsWeekdayAllowed(entryDt.day_of_week))
   {
      if(gVerboseDecisionLog)
      {
         PrintFormat("ENTRY TRACE: weekday %d blocked by filter",entryDt.day_of_week);
      }
      return;
   }
   if(!EntryHourAllowed(entryDt.hour))
   {
      if(gVerboseDecisionLog)
      {
         PrintFormat("ENTRY TRACE: hour %02d blocked by whitelist %02d-%02d (wrap=%s)",
                     entryDt.hour,gHourFilterStart,gHourFilterEnd,
                     (gHourFilterStart>gHourFilterEnd)?"true":"false");
      }
      return;
   }

   if(!gConfig.enableFallbackEntry && window!=SESSION_CORE)
   {
      if(gVerboseDecisionLog)
         Print("ENTRY TRACE: fallback disabled -> only core session trades allowed");
      return;
   }

   if(gConfig.lateEntryCutoffHour>=0)
   {
      int cutoff = MathMax(0,MathMin(23*60+59,gConfig.lateEntryCutoffHour*60 + gConfig.lateEntryCutoffMinute));
      int minutesNow = entryDt.hour*60 + entryDt.min;
      if(minutesNow>cutoff)
      {
         if(gVerboseDecisionLog)
         {
            PrintFormat("ENTRY TRACE: late cutoff %02d:%02d exceeded at %02d:%02d",cutoff/60,cutoff%60,entryDt.hour,entryDt.min);
         }
         return;
      }
   }

   double scoreThreshold = (window==SESSION_CORE ? gConfig.biasScoreThresholdCore : gConfig.biasScoreThresholdEdge);
   if(regimeBucket==REGIME_LOW)
      scoreThreshold += gConfig.biasScoreRegimeLowBoost;
   else if(regimeBucket==REGIME_HIGH)
      scoreThreshold += gConfig.biasScoreRegimeHighBoost;
   if(useFallback)
      scoreThreshold *= gConfig.fallbackScoreDiscount;

   if(!gConfig.bypassSlopeScoreCheck)
   {
      double biasScoreAbs = MathAbs(bias.score);
      if(biasScoreAbs < scoreThreshold)
      {
         if(gVerboseDecisionLog)
         {
            PrintFormat("ENTRY TRACE: bias score %.4f below threshold %.4f (regime=%d window=%d)",biasScoreAbs,scoreThreshold,(int)regimeBucket,(int)window);
         }
         return;
      }
   }

   bool directionResolved = (bias.direction!=0);
   if(!gConfig.bypassSlopeVoteCheck)
   {
      int slopeVotes = 0;
      if(MathAbs(bias.slopeH1)>=gConfig.biasSlopeConfirmH1) slopeVotes++;
      if(MathAbs(bias.slopeH4)>=gConfig.biasSlopeConfirmH4) slopeVotes++;
      if(MathAbs(bias.slopeD1)>=gConfig.biasSlopeConfirmD1) slopeVotes++;

      if(directionResolved && slopeVotes<2 && bias.strength!=BIAS_STRONG && !useFallback)
      {
         if(gVerboseDecisionLog)
         {
            PrintFormat("ENTRY TRACE: slope confirmations=%d below requirement for bias strength %d",slopeVotes,(int)bias.strength);
         }
         return;
      }

      if(directionResolved && !useFallback)
      {
         if(bias.direction>0 && bias.slopeD1 < gConfig.biasSlopeConfirmD1)
         {
            if(gVerboseDecisionLog)
               Print("ENTRY TRACE: D1 slope insufficient for long bias");
            return;
         }
         if(bias.direction<0 && (-bias.slopeD1) < gConfig.biasSlopeConfirmD1)
         {
            if(gVerboseDecisionLog)
               Print("ENTRY TRACE: D1 slope insufficient for short bias");
            return;
         }
      }
   }

   if(regimeBucket==REGIME_LOW && bias.strength==BIAS_NEUTRAL && !useFallback)
   {
      if(gVerboseDecisionLog)
         Print("ENTRY TRACE: neutral bias blocked in low-vol regime");
      return;
   }

   MqlRates rates[];
   ArraySetAsSeries(rates,true);
   int barsNeeded = MathMax(6,gConfig.breakoutRangeBars+2);
   int copied = CopyRates(_Symbol,ENTRY_TIMEFRAME,0,barsNeeded,rates);
   if(copied<3)
   {
      if(gVerboseDecisionLog)
         PrintFormat("ENTRY TRACE: insufficient rate data copied=%d",copied);
      return;
   }

   EntrySignal signal;
   bool allowAggressiveBoost = (gConfig.allowAggressiveEntries && RecentPnLPositive());
   if(!gEntry.Evaluate(bias,gRegime,window,rates,copied,useFallback,useFallback,gVerboseDecisionLog,allowAggressiveBoost,signal))
   {
      if(gVerboseDecisionLog)
         Print("ENTRY TRACE: EntryEngine returned no signal");
      return;
   }

   if(HasDirectionalPosition(signal.direction))
   {
      AnnotateChart("Position in same direction already open",clrSilver);
      return;
   }

   AttemptEntry(signal);
}

//+------------------------------------------------------------------+
//| Manage open positions                                            |
//+------------------------------------------------------------------+
// ManageOpenPositions delegates all R-based exit logic to the ExitEngine.
void ManageOpenPositions()
{
   gExit.Manage(gBroker,gSizer,gRegime);
}

//+------------------------------------------------------------------+
//| Check for open position in direction                             |
//+------------------------------------------------------------------+
bool HasDirectionalPosition(const int direction)
{
   if(direction==0)
      return false;

   ENUM_POSITION_TYPE need = (direction>0 ? POSITION_TYPE_BUY : POSITION_TYPE_SELL);
   for(int i=PositionsTotal()-1;i>=0;i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(!PositionSelectByTicket(ticket))
         continue;
      if(PositionGetString(POSITION_SYMBOL)!=_Symbol)
         continue;
      if((ulong)PositionGetInteger(POSITION_MAGIC)!=MAGIC_NUMBER)
         continue;
      if((ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE)!=need)
         continue;
      return true;
   }
   return false;
}

//+------------------------------------------------------------------+
//| Attempt to open trade                                            |
//+------------------------------------------------------------------+
// AttemptEntry performs spread/risk checks, position sizing and order placement for validated signals.
void AttemptEntry(const EntrySignal &signal)
{
   if(DEBUG_MODE)
   {
      string dirStr = DirectionToString(signal.direction);
      string sessionStr = SessionWindowToString(signal.session,signal.fallbackRelaxed);
      PrintFormat("ENTRY DEBUG: signal dir=%s score=%.2f biasDir=%d biasScore=%.2f slopes=H1 %.3f H4 %.3f D1 %.3f session=%s fallback=%s",
                  dirStr,signal.quality,signal.biasDirection,signal.biasScore,
                  signal.biasSlopeH1,signal.biasSlopeH4,signal.biasSlopeD1,
                  sessionStr,signal.fallbackRelaxed?"true":"false");
      PrintFormat("ENTRY DEBUG: AttemptEntry dir=%d entry=%.2f stop=%.2f quality=%.2f biasStrength=%d riskScale=%.2f fallback=%s",
                  signal.direction,signal.entryPrice,signal.stopLoss,signal.quality,(int)signal.biasStrength,
                  signal.riskScale,signal.fallbackRelaxed?"true":"false");
   }
   double stopPoints = gSizer.StopDistancePoints(signal.entryPrice,signal.stopLoss);
   if(stopPoints<=0.0)
   {
      if(DEBUG_MODE)
         Print("ENTRY DEBUG: stopPoints <= 0 -> abort entry");
      return;
   }

   if(DEBUG_MODE)
      PrintFormat("ENTRY DEBUG: computed stopPoints=%.1f",stopPoints);

   double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);
   double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   double point = SymbolInfoDouble(_Symbol,SYMBOL_POINT);
   if(point<=0.0)
      point = _Point;
   if(point>0.0)
   {
      int spreadPts = (int)MathRound((ask-bid)/point);
      if(spreadPts>MAX_SPREAD_POINTS)
      {
         if(ENABLE_CHART_ANNOTATIONS)
            AnnotateChart("Spread zu hoch",clrTomato);
         if(DEBUG_MODE)
            PrintFormat("ENTRY DEBUG: spreadPts=%d > MAX_SPREAD_POINTS=%d -> skip entry",spreadPts,MAX_SPREAD_POINTS);
         else
            PrintFormat("Spread %dpt > MAX_SPREAD_POINTS %d -> Entry verworfen",spreadPts,MAX_SPREAD_POINTS);
         return;
      }
      else if(DEBUG_MODE)
      {
         PrintFormat("ENTRY DEBUG: spreadPts=%d within limit %d",spreadPts,MAX_SPREAD_POINTS);
      }
   }

   double volume=0.0;
   double riskPercent=0.0;
   if(!gRisk.AllowNewTrade(stopPoints,gSizer,gRegime,volume,riskPercent,signal.riskScale))
   {
      AnnotateChart("Risk guard prevented entry",clrTomato);
      if(DEBUG_MODE)
         Print("ENTRY DEBUG: RiskEngine.AllowNewTrade() returned false");
      return;
   }

   if(DEBUG_MODE)
      PrintFormat("ENTRY DEBUG: proposed volume=%.4f riskPercent=%.2f%%",volume,riskPercent);

   if(!gRisk.HasSufficientMargin(signal.direction,volume,signal.entryPrice))
   {
      if(ENABLE_CHART_ANNOTATIONS)
         AnnotateChart("Margin check failed",clrTomato);
      if(DEBUG_MODE)
         Print("ENTRY DEBUG: Margin check failed -> entry skipped");
      else
         Print("Margin check failed -> entry skipped");
      return;
   }

   double tp = 0.0;
   if(gConfig.useHardFinalTP)
   {
      tp = signal.entryPrice + signal.direction*gConfig.finalTarget_R*stopPoints*point;
   }
   if(!gBroker.OpenPosition(signal.direction,volume,signal.entryPrice,signal.stopLoss,tp))
   {
      if(DEBUG_MODE)
         PrintFormat("ENTRY DEBUG: gBroker.OpenPosition() failed dir=%d",signal.direction);
      else
         PrintFormat("Order open failed for direction %d",signal.direction);
      return;
   }

   for(int i=PositionsTotal()-1;i>=0;i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(!PositionSelectByTicket(ticket))
         continue;
      if(PositionGetString(POSITION_SYMBOL)!=_Symbol)
         continue;
      if((ulong)PositionGetInteger(POSITION_MAGIC)!=MAGIC_NUMBER)
         continue;
      gExit.Register(ticket,signal,stopPoints,volume,riskPercent,gBiasLabel);
      gRisk.OnTradeOpened(riskPercent);
      AnnotateChart(StringFormat("Opened %s %.2flots",signal.direction>0?"BUY":"SELL",volume),clrGreen);
      if(DEBUG_MODE)
         PrintFormat("ENTRY DEBUG: Opened position volume=%.2f direction=%d",volume,signal.direction);
      RecordEntryTime(TimeCurrent(),signal.fallbackRelaxed);
      break;
   }
}

string SessionWindowToString(const SessionWindow window,const bool fallback)
{
   string label = "NONE";
   if(window==SESSION_CORE)
      label = "CORE";
   else if(window==SESSION_EDGE)
      label = "EDGE";
   if(fallback && window!=SESSION_NONE)
      label = label + " (FALLBACK)";
   return label;
}

string DirectionToString(const int direction)
{
   if(direction>0)
      return "LONG";
   if(direction<0)
      return "SHORT";
   return "FLAT";
}

//+------------------------------------------------------------------+
//| Chart annotation helper                                          |
//+------------------------------------------------------------------+
void AnnotateChart(const string message,const color col)
{
   if(!ENABLE_CHART_ANNOTATIONS)
      return;
   Comment(message);
}

//+------------------------------------------------------------------+
//| Close all positions                                              |
//+------------------------------------------------------------------+
void CloseAllPositions()
{
   for(int i=PositionsTotal()-1;i>=0;i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(!PositionSelectByTicket(ticket))
         continue;
      if(PositionGetString(POSITION_SYMBOL)!=_Symbol)
         continue;
      if((ulong)PositionGetInteger(POSITION_MAGIC)!=MAGIC_NUMBER)
         continue;
      gBroker.ClosePosition(ticket);
   }
}

void RecordEntryTime(const datetime entryTime,const bool fallbackTrade)
{
   CleanupEntryHistory(entryTime);
   int size = ArraySize(gEntryHistory);
   ArrayResize(gEntryHistory,size+1);
   gEntryHistory[size] = entryTime;
   if(fallbackTrade)
      gFallbackUsedThisWeek = true;
}

void CleanupEntryHistory(const datetime reference)
{
   int size = ArraySize(gEntryHistory);
   if(size<=0)
      return;
   datetime cutoff = reference - 7*24*3600;
   int writeIndex = 0;
   for(int i=0;i<size;i++)
   {
      if(gEntryHistory[i]>=cutoff)
         gEntryHistory[writeIndex++] = gEntryHistory[i];
   }
   if(writeIndex!=size)
      ArrayResize(gEntryHistory,writeIndex);
}

int EntriesLastSevenDays(const datetime reference)
{
   CleanupEntryHistory(reference);
   return ArraySize(gEntryHistory);
}

int ComputeWeekId(const datetime time)
{
   if(time<=0)
      return -1;
   MqlDateTime dt;
   TimeToStruct(time,dt);
   int week = (int)MathFloor((double)dt.day_of_year/7.0);
   return dt.year*100 + week;
}

bool ShouldUseFallbackEntry(const datetime signalTime,const int recentEntries)
{
   if(!gConfig.enableFallbackEntry)
      return false;
   if(signalTime<=0)
      return false;
   if(gFallbackUsedThisWeek)
      return false;
   MqlDateTime dt;
   TimeToStruct(signalTime,dt);
   if(!gConfig.enableWeekdayFallback)
   {
      if(recentEntries>=2)
         return false;
      if(dt.day_of_week!=5)
         return false;
      if(dt.hour<gConfig.fallbackMinHour)
         return false;
   }
   else
   {
      if(dt.day_of_week==0 || dt.day_of_week==6)
         return false;
      if(dt.hour<gConfig.fallbackMinHour)
         return false;
      if(gConfig.fallbackMaxPer7D>0 && recentEntries>=gConfig.fallbackMaxPer7D)
         return false;
   }
   return true;
}

void ResetRecentPnL()
{
   for(int i=0;i<RECENT_TRADE_WINDOW;i++)
      gRecentTradePnL[i] = 0.0;
   gRecentTradeCount = 0;
}

void RecordClosedTradePnL(const double profit)
{
   if(RECENT_TRADE_WINDOW<=0)
      return;
   if(gRecentTradeCount<RECENT_TRADE_WINDOW)
   {
      gRecentTradePnL[gRecentTradeCount++] = profit;
   }
   else
   {
      for(int i=1;i<RECENT_TRADE_WINDOW;i++)
         gRecentTradePnL[i-1] = gRecentTradePnL[i];
      gRecentTradePnL[RECENT_TRADE_WINDOW-1] = profit;
   }
}

bool RecentPnLPositive()
{
   // Used to temporarily relax quality thresholds when the last trades netted profit.
   double sum = 0.0;
   for(int i=0;i<gRecentTradeCount;i++)
      sum += gRecentTradePnL[i];
   return (gRecentTradeCount>0 && sum>0.0);
}

bool IsWeekdayAllowed(const int dayOfWeek)
{
   switch(dayOfWeek)
   {
      case 1: return AllowMondayTrading;
      case 2: return AllowTuesdayTrading;
      case 3: return AllowWednesdayTrading;
      case 4: return AllowThursdayTrading;
      case 5: return AllowFridayTrading;
      default: return false;
   }
}

bool EntryHourAllowed(const int hour)
{
   if(!gUseHourWhitelist)
      return true;
   int clampedHour = MathMax(0,MathMin(23,hour));
   if(gHourFilterStart==gHourFilterEnd)
      return (clampedHour==gHourFilterStart);
   if(gHourFilterStart<gHourFilterEnd)
      return (clampedHour>=gHourFilterStart && clampedHour<=gHourFilterEnd);
   return (clampedHour>=gHourFilterStart || clampedHour<=gHourFilterEnd);
}

//+------------------------------------------------------------------+
//| Trade transaction                                                |
//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction &trans,const MqlTradeRequest &request,const MqlTradeResult &result)
{
   if(trans.type==TRADE_TRANSACTION_DEAL_ADD && trans.deal>0)
   {
      ulong deal = trans.deal;
      ENUM_DEAL_ENTRY entryType = (ENUM_DEAL_ENTRY)HistoryDealGetInteger(deal,DEAL_ENTRY);
      double profit = HistoryDealGetDouble(deal,DEAL_PROFIT);
      ulong positionId = (ulong)HistoryDealGetInteger(deal,DEAL_POSITION_ID);
      if(entryType==DEAL_ENTRY_OUT)
      {
         bool positionStillOpen = PositionSelectByTicket(positionId);
         double riskRemoved = 0.0;
         if(!positionStillOpen)
         {
            double exitPrice = HistoryDealGetDouble(deal,DEAL_PRICE);
            datetime exitTime = (datetime)HistoryDealGetInteger(deal,DEAL_TIME);
            double commission = HistoryDealGetDouble(deal,DEAL_COMMISSION);
            double swap = HistoryDealGetDouble(deal,DEAL_SWAP);
            riskRemoved = gExit.OnPositionClosed(positionId,exitPrice,exitTime,profit,commission,swap);
         }
         if(!positionStillOpen)
         {
            gRisk.OnTradeClosed(profit,riskRemoved);
            RecordClosedTradePnL(profit);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| OnTester acceptance checks                                       |
//+------------------------------------------------------------------+
double OnTester()
{
   double trades = TesterStatistics((ENUM_STATISTICS)STAT_TRADES);
   double winTrades = TesterStatistics((ENUM_STATISTICS)STAT_PROFIT_TRADES);
   double profitFactor = TesterStatistics((ENUM_STATISTICS)STAT_PROFIT_FACTOR);
   double maxDD = TesterStatistics((ENUM_STATISTICS)STAT_EQUITY_DDRELATIVE);
   double sharpe = TesterStatistics((ENUM_STATISTICS)STAT_SHARPE_RATIO);
   double avgHoldHours = TesterStatistics((ENUM_STATISTICS)STAT_AVG_HOLD_TIME)/3600.0;
   double equityCorr = TesterStatistics((ENUM_STATISTICS)STAT_LINEAR_CORRELATION_EQUITY);
   double winRate = (trades>0.0 ? winTrades/trades*100.0 : 0.0);

   bool pass=true;
   if(trades<2500 || trades>3400) pass=false;
   if(winRate<49.0 || winRate>53.0) pass=false;
   if(profitFactor<1.26 || profitFactor>1.36) pass=false;
   if(maxDD>12.0) pass=false;
   if(sharpe<1.6 || sharpe>2.4) pass=false;
   if(avgHoldHours<6.0 || avgHoldHours>10.0) pass=false;
   if(equityCorr<0.80) pass=false;

   PrintFormat("Tester summary: trades=%.0f winRate=%.2f%% PF=%.2f DD=%.2f%% sharpe=%.2f avgHold=%.2fh corr=%.2f",
               trades,winRate,profitFactor,maxDD,sharpe,avgHoldHours,equityCorr);
   return pass?1.0:0.0;
}
